jmp start

sysc:
    pop rcx

    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop r10
    pop r8
    pop r9

    push rcx
    syscall
    ret

deref_byte: ; takes (ptr) and returns *ptr
  pop rdx
  pop rax
  push rdx
  movb rax, [rax]
  and rax, 0xFF
  ret

return:
  pop rcx
  pop rax
  push rcx
  ret

load_func: ; (ptr) -> ret *ptr
  pop rdx
  pop rax
  mov rax, [rax]
  push rdx
  ret

store_func: ; (ptr x) -> *ptr = x; RET
  pop rdi
  pop rax
  pop rdx
  mov [rax], rdx
  push rdi
  ret

add_func: ; takes (ret a b) and returns a+b
  pop rbx
  pop rax
  pop rcx
  push rbx
  add rax, rcx
  ret

div_func:
  pop rcx
  pop rax
  mov rdx, 0
  pop rdi
  idiv rdi
  jmp rcx

mul_func: ; UNSIGNED
  pop rcx
  pop rax
  pop rdx
  mul rdx
  jmp rcx

mod_func:
  pop rcx
  pop rax
  mov rdx, 0
  pop rdi
  idiv rdi
  mov rax, rdx
  jmp rcx

decomp: ; takes (cont -> cont a b) and returns a and b
  |decomp_cont [rsp]|
  add rsp, 8
  pop rcx ; f
  push rax
  push rcx
  jmp runtime_call
  decomp_cont:
    pop rdi ; ret
    pop rax
    jmp rdi

compare: ; takes in (a b equal_cont diff_cont) and calls equal_cont or diff_cont depending on a == b
  pop rax
  pop rcx
  pop rdi
  pop rsi
  cmp rax, rcx
  jne compare_fail
  push rdi
  jmp runtime_call

  compare_fail:
    push rsi
    jmp runtime_call

(or: ret cont1 cont2 ->
  cont1 (-> return ret cont1) (-> return ret cont2)
)

(if: ret v cont ->
  $break = (-> return ret 0);
  v (-> cont break) break
)
(if_ret: ret v cont ->
  $break = (-> return ret 0);
  v (->
    ${cont};
    break
  )
  break
)
(if_else_ret: ret v cont1 cont2 ->
  v (-> return ret {cont1})
  (-> return ret {cont2})
)

(!ne: a b -> 
  callcc (ret -> compare a b (-> ret (x y -> y)) (-> ret (x y -> x)))
)
(!not: x -> callcc (ret -> x (-> ret (a b -> b)) (-> ret (a b -> a))))

(!compare_bool: a b ->
  callcc (ret -> compare a b (-> ret (x y -> x)) (-> ret (x y -> y)))
)
constant_strings:
push_string:
dq "push "
jmp_string:
dq "jmp "
newline_string:
dq 10

inpf: dq 0
outf: dq 0
flen: dq 0
iter: dq 0
ofar: dq 0  ; offset array

exit:
  mov r0, 60
  mov r7, 0
  syscall
error:
  mov [outf], 2
  jmp error_help
(error_help: num ->
  ${printf "error "};
  ${print_num num};
  ${printf "\n"};
  ${sysc 60 1 0 0 0 0 0};
  exit
)

runtime_call:
  ; first input is closure containing | number of operands including function, function, environment |
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_loop
  
  pop rax
  jmp rax

runtime_call_ret:
  ; first input is closure containing | number of operands including function, function, environment |
  pop rbp
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_ret_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_ret_loop
  
  pop rax
  push rbp
  jmp rax
  
callcc: ; takes (cont -> ..) and returns the value that cont recieves
  |callcc_cont [rsp]|
  pop rcx
  pop rbx ; f
  push rax
  push rbx
  jmp runtime_call

  callcc_cont:
    pop rcx
    pop rax
    push rcx
    ret

page_pointer:
dq 0
memory_left:
dq 0
malloc:
  push rcx
  push rdx
  push rsi
  push rdi
  push r8
  push r9
  push r10
  push r11

  cmp [memory_left], rdi
  jl new_page
  jmp malloc_ret
  
  new_page:
  push rdi
  mov rsi, 4096
  mov rdi, 0               ; adress
  mov rdx, 3               ; PROT_READ | PROT_WRITE
  mov r10, 0x22           ; MAP_SHARED | MAP_ANONYMOUS
  mov r8, -1              ; file descriptor empty, anonymous
  mov r9, 0               ; offset
  mov rax, 9               ; mmap
  syscall
  pop rdi
  mov [page_pointer], rax
  mov [memory_left], 4096

  malloc_ret:
  mov rax, [page_pointer]
  add [page_pointer], rdi
  sub [memory_left], rdi

  pop r11
  pop r10
  pop r9
  pop r8
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  ret

malloc_f:
  pop rcx
  pop rdi
  push rcx
  jmp malloc

(bool_true: cont_true cont_false -> cont_true)
(bool_false: cont_true cont_false -> cont_false)


(make_pair: cont a b -> cont (cont -> cont a b))

(!make_nil: -> return (cont_nil cont_leaf cont_internal -> cont_nil))
(!make_leaf: l r -> return (cont_nil cont_leaf cont_internal -> cont_leaf l r))
(!make_internal: a b -> return (cont_nil cont_leaf cont_internal -> cont_internal a b))

make_leaf_imperative:
  push rsi
  push rdi
  call make_leaf
  ret
  
make_internal_imperative:
  push rsi
  push rdi
  call make_internal
  ret

prin:                   ; printst
push rax
push rcx
push rdx
push rsi
push rdi
push r11
mov rdx, rdi
mov rdi, [outf]
mov rsi, r4
add rsi, 56
mov rax, 1
syscall
pop r11
pop rdi
pop rsi
pop rdx
pop rcx
pop rax
ret

scmp:
  cmp rdi, rsi
  je end_of_string
  cmp rdx, rcx
  je end_of_string

  sub rax, rax
  movb al, [rdi]
  push rbx
  sub rbx, rbx
  movb bl, [rdx]
  sub rax, rbx
  pop rbx
  add rdi, 1
  add rdx, 1
  cmp rax, 0
  je scmp
  jl less
  mov rax, 1
  ret
  less:
  mov rax, -1
  ret

  end_of_string:
  mov rax, 0
  cmp rdi, rsi
  jne not_first_shorter
  add rax, -1
  not_first_shorter:
  cmp rdx, rcx
  jne not_second_shorter
  add rax, 1
  not_second_shorter:
  ret

cur_label:
  dq 1
gen_label:
  |cur_label|
  mov rdx, rax
  mov rcx, [cur_label]
  add [cur_label], 1
  mov [rdx], "f"
  add rdx, 1
  gen_label_loop:
  mov rbx, rcx
  and rbx, 7
  add rbx, "0"
  movb [rdx], rbx
  add rdx, 1
  shr rcx, 3
  cmp rcx, 0
  jne gen_label_loop
  ret

gen_label_func: ;  -> (cont l r)
  call gen_label
  pop rcx
  push rdx
  push rax
  push rcx
  jmp runtime_call

(gen_label_ret: ret -> gen_label_func (l r -> return ret l r))

str_equal_func: ; (a b l r cont)
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  call scmp
  cmp rax, 0
  je str_equal_equal
  
  |bool_false|
  pop rcx
  push rax
  push rcx
  jmp runtime_call

  str_equal_equal:
  |bool_true|
  pop rcx
  push rax
  push rcx
  jmp runtime_call
  
id_func:
  jmp runtime_call

print_range: ; FOLLOWS SYSTEM V ABI
  ; prints [rdi, rsi) to outf
  mov rdx, rsi        ; length of print
  sub rdx, rdi
  mov rsi, rdi ; rsi already stores buffer lcoation
  mov rdi, [outf]
  mov rax, 1
  syscall
  ret

print_char_help:
  push rdi
  mov rdx, 1
  mov rsi, rsp
  mov rdi, [outf]
  mov rax, 1
  syscall
  pop rdi
  ret

print_range_ret:
  pop rax
  pop rdi
  pop rsi
  push rax
  call print_range
  ret

print_char:
  pop rax
  pop rdi
  push rax
  call print_char_help
  ret

print_range_line_func:
  ; takes l r cont and prints l r then calls cont
  pop rdi
  pop rsi
  call print_range_line
  jmp runtime_call


print_string_func:
  ; takes l len cont and prints l r then calls cont
  pop rdi
  pop rsi
  add rsi, rdi
  call print_range
  jmp runtime_call

print_substring_func:
  ; takes l a b cont and prints (l+a, l+b) then calls cont
  pop rax
  pop rdi
  pop rsi
  add rdi, rax
  add rsi, rax
  call print_range
  jmp runtime_call

print_substring_line_func:
  ; takes l a b cont and prints (l+a, l+b) then calls cont
  pop rax
  pop rdi
  pop rsi
  add rdi, rax
  add rsi, rax
  call print_range_line
  jmp runtime_call

print_string_line_func:
  ; takes l len cont and prints l r then calls cont
  pop rdi
  pop rsi
  add rsi, rdi
  call print_range_line
  jmp runtime_call

(print_num_help: v cont ->
  ${if {compare_bool v 0} (break -> cont)};
  print_num_help {div_func v 10} (->
    ${print_char {add_func {deref_byte "0"} {mod_func v 10}}};
    cont
  )
)
(print_num: ret v -> callcc ret (ret -> print_num_help v (-> ret 0)))

(printf_help: cont l ->
  $lb = {deref_byte l};
  ${if {compare_bool lb 0} (break ->
    cont
  )};
  ${if {compare_bool lb 123} (break a b ->
    ${print_range_ret a b};
    printf_help cont {add_func l 2}
  )};
  ${print_char {deref_byte l}};
  printf_help cont {add_func l 1}
)
(printf: ret l -> callcc ret (ret -> printf_help (-> ret 0) l))

(tree_size_help: tree cont ->
tree
  (-> cont 0)
  (l r ->
    cont 1
  )
  (a b -> tree_size_help a (count_a -> (-> tree_size_help b (count_b -> cont {add_func count_a count_b}))))
)

(!tree_size: tree -> callcc (ret -> tree_size_help tree ret))
(print_tree: tree cont -> traverse_tree tree
(l r cont -> ${print_range_ret l r};
cont) cont)

(traverse_tree: tree action cont -> tree cont (l r -> action l r cont) 
(traverse_internal: a b -> traverse_tree a action (-> traverse_tree b action cont)))

; calls cont with new_tree
(map_tree: tree action cont -> tree
  (-> $nil = {make_nil};
      cont nil)
  (l r -> action l r cont) 
(map_internal: a b -> map_tree a action (new_a -> map_tree b action (new_b -> cont {make_internal new_a new_b}))))

(map_tree_ret_help: ret tree action ->
  tree
    (-> ret {make_nil})
    (l r -> ret {action l r})
    (a b -> map_tree_ret_help (new_a -> map_tree_ret_help (new_b -> ret {make_internal new_a new_b}) b action) a action)
)
(map_tree_ret: ret tree action -> callcc ret (ret -> map_tree_ret_help ret tree action))

(map_tree_iota_help: ret n tree action ->
  tree
    (-> ret n {make_nil})
    (l r -> ret {add_func n 1} {action n l r})
    (a b -> map_tree_iota_help (na new_a -> map_tree_iota_help (nb new_b -> ret nb {make_internal new_a new_b}) na b action) n a action)
)
(map_tree_iota: ret tree action -> callcc ret (ret -> map_tree_iota_help (n t -> ret t) 0 tree action))

(reverse_tree: tree cont -> tree (-> cont {make_nil}) ( l r -> cont {make_leaf l r})
(a b -> reverse_tree a (new_a -> reverse_tree b (new_b -> cont {make_internal new_b new_a})))
)

(search_tree: tree l r cont -> tree (-> cont (a b -> b)) (a b -> str_equal_func l r a b cont)
(a b -> search_tree a l r (res -> res (-> cont (a b -> bool_true a b)) (-> search_tree b l r cont))))

(!search_tree_ret: tree l r -> callcc (ret ->
  search_tree tree l r (res -> res (-> ret (a b -> a)) (-> ret (a b -> b)))
))

(!merge_context: left right ->
  $nright = {map_tree_ret right (!l r -> callcc (ret ->
    ${if {search_tree_ret left l r} (break -> ret {make_nil})};
    ret {make_leaf l r}
  ))};
  return {make_internal left right}
)

reverse_tree_imperative:
  sub rsp, 16
  mov [rsp], rdi
  |reverse_tree_lambda|
  mov [rsp+8], rax
  jmp reverse_tree
  reverse_tree_lambda:
    pop rax
    ret

map_tree_imperative:
  sub rsp, 24
  mov [rsp], rdi
  mov [rsp+8], rsi
  |map_tree_imperative_lambda|
  mov [rsp+16], rax
  jmp map_tree
  map_tree_imperative_lambda:
    pop rax
    ret

print_tree_imperative:
  sub rsp, 16
  mov [rsp], rdi
  |print_tree_imperative_done|
  mov [rsp+8], rax
  jmp print_tree
  print_tree_imperative_done:
  ret

print_range_pair:
  push rdi
  |print_range_pair_lambda|
  pop rdi
  push rax
  push rdi
  jmp runtime_call
  print_range_pair_lambda:
    pop rdi
    pop rsi
    call print_range
    ret

make_pair_imperative:
  push rsi
  push rdi
  |make_pair_imperative_lambda|
  push rax
  jmp make_pair
  make_pair_imperative_lambda:
    pop rax
    ret

print_ranges_function:

print_ranges:
  cmp rdi, 0
  jne print_ranges_continue
  ret
  print_ranges_continue:
  push rdi
  |print_ranges_lambda|
  pop rdi
  push rax
  push rdi
  jmp runtime_call
  print_ranges_lambda:
    pop rdi
    call print_range_pair
    pop rdi
    jmp print_ranges

print_range_line:
  call print_range
  call println
  ret

println:
  push 10
  mov rdi, 1
  call prin
  add rsp, 8
  ret


println_func:
  call println
  jmp runtime_call

is_alpha:           ; is alpha
  cmp r7, "a"      ; a
  jl nalp
  cmp r7, "z"     ; z
  jg nalp
  yalp:
  mov r0, 1
  ret
  nalp:
  mov r0, 0
  ret

is_alpha_func:
  pop rdi
  call is_alpha
  pop rcx
  push rax
  push rcx
  jmp runtime_call

(!is_alpha_ret: c -> callcc (ret -> is_alpha_func c ret))

is_digit:           ; is alpha
  cmp r7, "0"
  jl not_digit
  cmp r7, "9"
  jg not_digit
  yes_digit:
  mov r0, 1
  ret
  not_digit:
  mov r0, 0
  ret

peek_character:
  sub rax, rax
  cmp r8, [flen]
  je peek_character_ret
  movb rax, [r8]
  peek_character_ret:
  ret

read_whitespace:
  cmp r8, [flen]
  je done_whitespace
  cmpb [r8], " "
  je not_done_whitespace
  cmpb [r8], 10
  je not_done_whitespace
  done_whitespace:
  ret
  not_done_whitespace:
  add r8, 1
  jmp read_whitespace

read_whitespace_func: ; (r8 flen cont)
  pop r8
  pop [flen]
  call read_whitespace
  pop rax
  push [flen]
  push r8
  push rax
  jmp runtime_call

(read_whitespace_ret: ret l r ->
  read_whitespace_func l r (l r -> return ret l r)
)

read_identifier: ; read identifier and return start and end pointers
  ; call read_whitespace
  push r8
  iloo:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  call is_alpha
  cmp rax, 1
  je identifier_loop_continue
  call is_digit
  cmp rax, 1
  je identifier_loop_continue
  cmp rcx, "_"
  je identifier_loop_continue
  jmp idon
  identifier_loop_continue:
  add r8, 1
  jmp iloo
  idon:
  pop rax
  mov rdx, r8
  ret

read_identifier_func: ; (r8 flen cont ->  l r r8 flen)
  pop r8
  pop [flen]
  call read_identifier
  pop rcx
  push rdx
  push rax
  push [flen]
  push r8
  push rcx
  jmp runtime_call

read_identifier_list_help:
  pop r8
  pop [flen]
  call make_nil
  push rax

  id_list_loop:
  call read_whitespace
  call read_identifier
  cmp rax, rdx
  je id_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp id_list_loop

  id_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

(read_identifier_list: ret l r -> 
  read_identifier_list_help l r (ids l r -> return ret l r ids)
)

(format_string: l r cont -> format_string_helper {make_nil} l l r cont)
(format_substring: base l r cont ->
  $l = {add_func base l};
  $r = {add_func base r};
  format_string l r cont
)
(format_help: fmt a b -> 
  compare a 1
  (-> b fmt)
  (-> fmt a b (fmt -> format_help fmt))
)
(format_string_helper: tree l mid r cont ->
  ${if {compare_bool mid r} (break ->
    cont {make_internal tree {make_leaf l mid}}
  )};
  ${if {compare_bool {deref_byte mid} 123} (break ->
    $new_mid = {add_func mid 2};
    $tree = {make_internal tree {make_leaf l mid}};
    cont (lb rb cont ->
      $tree = {make_internal tree {make_leaf lb rb}};
      format_string_helper tree new_mid new_mid r cont
    )
  )};
  $new_mid = {add_func mid 1};
  format_string_helper tree l new_mid r cont
)

read_operand_list:
  pop r8
  pop [flen]
  call make_nil
  push rax

  op_list_loop:
  call read_whitespace
  call read_operand
  cmp rax, rdx
  je op_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp op_list_loop

  op_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

read_operand_list_imperative:
  sub rsp, 24
  mov [rsp], rdi
  mov [rsp+8], rsi
  |read_operand_list_imperative_lambda|
  mov [rsp+16], rax
  jmp read_operand_list
  read_operand_list_imperative_lambda:
    pop rax
    pop r8
    pop [flen]
    ret

read_operand:
  cmpb [r8], "\["
  jne read_identifier
  push r8
  memory_operand_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\]"
  je memory_operand_loop_done
  add r8, 1
  jmp memory_operand_loop
  memory_operand_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure:
  cmpb [r8], "\|"
  jne read_operand
  push r8
  add r8, 1
  id_or_closure_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\|"
  je id_or_closure_loop_done
  add r8, 1
  jmp id_or_closure_loop
  id_or_closure_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function:
  cmpb [r8], "\("
  jne read_id_or_closure
  push r8
  mov rax, 0
  id_or_closure_or_func_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  
  cmp rcx, "\("
  jne not_idocf_open
  add rax, 1
  not_idocf_open:
  cmp rcx, "\)"
  jne not_idocf_close
  sub rax, 1
  not_idocf_close:
  cmp rax, 0
  je id_or_closure_or_func_loop_done
  add r8, 1
  jmp id_or_closure_or_func_loop
  id_or_closure_or_func_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function_func: ; (l r -> a b l r)
  pop r8
  pop [flen]

  call read_whitespace

  call read_id_or_closure_or_function
  pop rcx
  push [flen]
  push r8
  push rdx
  push rax
  push rcx
  jmp runtime_call

closure_map_arg:
  jmp suff_strings_end
  mov_string:
  db "mov rcx, "
  mov_string_end:
  suff_strings:
  db "mov [rdx], rcx\\nadd rdx, 8\\n"
  suff_strings_end:
  lea rdi, [mov_string]
  lea rsi, [mov_string+9]
  call print_range
  pop rdi
  pop rsi
  call print_range_line
  lea rdi, [suff_strings]
  lea rsi, [suff_strings+26]
  call print_range

  pop rax
  push 0
  push rax
  jmp runtime_call


closure_header:
  dq "mov rdi,"
  dq " 800"
  
  dq "call mal"
  dq "loc"
  
  dq "lea rdx,"
  dq " [rax+8]"

print_closure_help:
  pop rax
  pop rdi
  push rax
  jmp print_closure
print_closure:
  push rdi
  lea rdi, [newline_string]
  lea rsi, [newline_string+1]
  call make_pair_imperative
  mov rdi, rax
  mov rsi, 0
  call make_pair_imperative
  push rax
  lea rdi, [closure_header]
  lea rsi, [closure_header+12]
  call make_pair_imperative
  mov rdi, rax
  pop rsi
  call make_pair_imperative
  mov rdi, rax
  call print_ranges
  lea rdi, [closure_header+16]
  lea rsi, [closure_header+27]
  call make_leaf_imperative
  mov rdi, rax
  call print_tree_imperative
  call println
  lea rdi, [closure_header+32]
  lea rsi, [closure_header+48]
  call print_range_line

  |closure_map_arg|
  mov rsi, rax
  pop rdi
  call map_tree_imperative

  
  lea rdi, [closure_footer]
  lea rsi, [closure_footer+12]
  call print_range_line
  
  lea rdi, [closure_footer+16]
  lea rsi, [closure_footer+26]
  call print_range_line
  
  lea rdi, [closure_footer+32]
  lea rsi, [closure_footer+42]
  call print_range_line
  
  lea rdi, [closure_footer+48]
  lea rsi, [closure_footer+62]
  call print_range_line
  ret

(!eof_closure_map_arg: fname_l fname_r pfname_l pfname_r ->
  return (!n l r -> 
    ${if_else_ret {compare_bool l fname_l} (!->
      ${printf "mov [rax+"};
      ${print_num {mul_func 8 {add_func 1 n}}};
      ${printf "], {}\n" l r};
    ) (!->
      ${printf "mov rcx, [{}{}]\nmov [rax+" pfname_l pfname_r l r};
      ${print_num {mul_func 8 {add_func 1 n}}};
      ${printf "], rcx\n"};
    )};
  )
)

(!print_closure_eof: fname_l fname_r pfname_l pfname_r context ->
  ${printf "mov rdi, "};
  $size = {tree_size context};
  ${print_num {mul_func 8 {add_func 1 size}}};
  ${printf "\ncall malloc\n"};
  $map_arg = {eof_closure_map_arg fname_l fname_r pfname_l pfname_r};
  ${map_tree_iota context map_arg};
  ${printf "mov [rax], "};
  ${print_num size};
  ${printf "\n"};
)

closure_footer:
  dq "sub rdx,"
  dq " rax"
  dq "shr rdx,"
  dq " 3"
  dq "sub rdx,"
  dq " 1"
  dq "mov [rax"
  dq "], rdx"

(parse_closure: lo hi cont ->
  $lo = {add_func lo 1};
  read_operand_list lo hi (op_list lo hi -> 
    $lo = {add_func lo 1};
    $a = {print_closure_help op_list};
    cont lo hi
  )
)

(print_pop_arg: fname_l fname_r l r cont ->
${printf "pop [{}{}]\n" fname_l fname_r l r};
cont 0)

(parse_label: pl pr cont -> read_whitespace_func pl pr 
(l r -> (rest_label -> $lb = {deref_byte l};
  compare lb 33 (-> $l = {add_func l 1};
                  rest_label l r (a b -> a))
                  (-> rest_label l r (a b -> b)))
  (pl pr is_returning -> read_identifier_func pl pr
  (l r fl fr -> read_whitespace_func l r 
  (l r -> $l_char = {deref_byte l};
    compare l_char 58
    (pl_has_label: -> $l = {add_func l 1};
     cont l r fl fr is_returning)
    (pl_no_label: -> gen_label_func (fl fr -> cont pl pr fl fr is_returning)))))
  ))

(read_new_context: old_context l r cont ->
  $l r new_args = {read_identifier_list l r}; 
  cont {make_internal old_context new_args} l r
)

(parse_function: ret old_context p_fname_l p_fname_r l r ->
  $lb = {deref_byte l};
  compare lb 40 (->
    $l_inner = {add_func l 1};
    parse_label l_inner r 
    (l r fname_l fname_r is_returning -> read_new_context old_context l r 
    (new_context l r -> read_whitespace_func l r
    (l r -> $l = {add_func l 2};
    $l r extra_context cexp = [read_cexp new_context fname_l fname_r l r is_returning];
    $l = {add_func l 1};
    return ret l r fname_l fname_r old_context (print_function: cont ->
      ${printf "jmp {}_end\n" fname_l fname_r};
      ${map_tree_ret extra_context (!l r -> printf "{}{}: dq 0\n" fname_l fname_r l r)};
      ${printf "{}:\n" fname_l fname_r};
      ${if_ret is_returning (!-> printf "pop rax\n")};
      ${map_tree_ret new_context (!l r -> callcc (ret -> print_pop_arg fname_l fname_r l r ret))};
      ${if_ret is_returning (!-> printf "push rax\n")};
      cexp (->
      ${if_ret is_returning (!-> printf "ret\n")};
      ${printf "{}_end:\n" fname_l fname_r};
      cont)))))
  )
  (-> return ret l r 0 0 old_context 0)
)

(read_func_operand_list: context fname_l fname_r l r cont -> read_func_operand_list_help context fname_l fname_r l r {make_nil} cont)
(read_func_operand_list_help: context fname_l fname_r l r tree cont ->
  read_whitespace_func l r
  (l r ->
  $l r texp = [read_texp context {make_nil} fname_l fname_r l r];
  compare texp 0 (-> cont tree l r)
  (->
    $leaf = {make_leaf texp 0};
    $tree = {make_internal tree leaf};
    read_func_operand_list_help context fname_l fname_r l r tree cont
  )
))

(add_to_context: context l r cont -> cont {make_internal context {make_leaf l r}})

(read_texp_ret: ret context ids fname_l fname_r l r ->
  $l r texp = [read_texp context ids fname_l fname_r l r];
  return ret l r texp
)
; returns l r texp
(read_texp: ret context ids fname_l fname_r l r ->
  $return_pop = (l r t -> return ret l r (cont ->
    t (-> ${map_tree_ret ids (!l r -> printf "pop [{}{}]\n" fname_l fname_r l r)};
    cont)
  ));
  $lb = {deref_byte l};
  ${if {compare_bool lb 91} (break -> read_rec_block context ids fname_l fname_r l r (l r t -> return ret l r t))};
  ${if {compare_bool lb 123} (break -> read_block context fname_l fname_r l r return_pop)};
  $lo hi fl fr context func = [parse_function context fname_l fname_r l r];
  (->
  ${if {ne func 0} (break -> 
    return_pop lo hi (cont -> func (->
      ${print_closure_eof fl fr fname_l fname_r {make_internal {make_leaf fl fr} context}};
      ${printf "push rax\n"};
      cont))
  )};
  read_const_string context fname_l fname_r l r (lo hi string ->
  ${if {ne string 0} (break -> 
    return_pop lo hi (cont -> ${string}; 
      cont)
  )};
  read_id_or_closure_or_function_func l r
  (a b l r -> compare a b (-> return ret l r 0) (-> return_pop l r (cont -> print_aexp context fname_l fname_r a b cont)))
)))

(print_cexp: aexp_list cont -> reverse_tree aexp_list
  (aexp_list -> map_tree aexp_list (aexp r cont -> aexp (-> cont 0))
  (aexp_list -> cont)))

(matches: ret a b -> 
  ${if {compare_bool {deref_byte a} 0} (break -> return ret (a b -> a))};
  ${if {ne {deref_byte a} {deref_byte b}} (break -> return ret (a b -> b))};
  matches ret {add_func a 1} {add_func b 1}
)

; 0 -> special, 1 -> id, 2 -> number, 3 -> string, 4 -> comment, 5 -> newline, 6 -> eof
; returns l r type il ir
(read_token: ret l r ->
  $l r = {read_whitespace_ret l r};
  ${if {matches "$" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "[" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "]" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "=" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches ";" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  error l
)

(read_rec_block: context ids fname_l fname_r orig_l r cont ->
  $l = orig_l;
  $l r t tl tr = {read_token l r};
  ${if {not {matches "[" tl}} (break -> return ret orig_l r 0)};
  $l r context cexp = [read_cexp context fname_l fname_r l r (a b -> a)];
  $l r t tl tr = {read_token l r};
  ${if {not {matches "]" tl}} (break -> return ret orig_l r 0)};
  cont l r (cont -> 
    $context = {map_tree_ret context (!l r -> callcc (ret ->
      ${if {search_tree_ret ids l r} (break -> ret {make_nil})};
      ret {make_leaf l r}
    ))};
    ${map_tree_ret context (!l r -> printf "push [{}{}]\n" fname_l fname_r l r)};
    cexp
    (-> reverse_tree context
    (rev_context ->
      $[printf "push rax\n"];
      $[if_ret {compare_bool {tree_size ids} 0} (!-> printf "add rsp, 8\n")];
      ${map_tree_ret ids (!l r -> printf "pop [{}{}]\n" fname_l fname_r l r)};
      ${map_tree_ret rev_context (!l r -> printf "pop [{}{}]\n" fname_l fname_r l r)};
      cont
    )))
)

(read_block: context fname_l fname_r l r cont ->
  $l = [add_func l 1];
  $l r = [read_whitespace_ret l r];
  $l r context cexp = [read_cexp context fname_l fname_r l r (a b -> a)];
  read_whitespace_func l r
  (l r -> $l = [add_func l 1];
  cont l r
    (cont -> cexp
    (-> $u = [printf "push rax\n"];
     cont)))
)

; returns l r context cexp
(read_cexp: ret context fname_l fname_r orig_l r is_returning ->
  $l = orig_l;
  $l r = {read_whitespace_ret l r};
  $lb = {deref_byte l};
  ${if {ne lb 36} (break -> read_function_application context fname_l fname_r l r is_returning (l r ct cexp -> return ret l r ct cexp))};
  $l r context stmt = [read_statement context fname_l fname_r orig_l r is_returning];
  ${if {compare_bool stmt 0} (break -> return ret orig_l r context 0)};
  $l r context cexp = [read_cexp context fname_l fname_r l r is_returning];
  return ret l r context (cont ->
    stmt (-> cexp cont)
  )
)

(read_statement: ret context fname_l fname_r orig_l r is_returning ->
  $l = orig_l;
  $l r t tl tr = {read_token l r};
  ${if {not {matches "$" tl}} (break -> return ret orig_l r context 0)};

  $l r context assign = [read_assignment context fname_l fname_r l r is_returning];
    return ret l r context (cont ->
    print_assign_cont assign cont
  )
)

(print_statement: ret assign ->
  $[print_assignment assign];
  return ret 0
)

(gen_label_tree: ret ->
  $il ir = {gen_label_ret};
  return ret {make_leaf il ir}
)

(read_eq_if: ret need l r ->
  ${if need (break ->
    $l r t tl tr = {read_token l r};
    ${if {not {matches "=" tl}} (break -> return 0 0)};
    return ret l r
  )};
  return ret l r
)

(read_assignment: ret context fname_l fname_r orig_l r is_returning ->
  $l = orig_l;
  $l r ids = {read_identifier_list l r};
  $is_empty_ids = {compare_bool {tree_size ids} 0};
  $ids = {if_else_ret is_empty_ids (!-> 
    return {gen_label_tree}
  )
  (!-> return ids)};
  $context = {make_internal context ids};
  $l r = {read_eq_if {not is_empty_ids} l r};
  ${if {compare_bool 0 l} (break -> return ret orig_l r context 0)};
  $l r = {read_whitespace_ret l r};
  $l r texp = [read_texp context ids fname_l fname_r l r];
  $l r t tl tr = {read_token l r};
  ${if {not {matches ";" tl}} (break -> return ret orig_l r context 0)};
  $assign = (cont -> cont texp);
  return ret l r context assign
)
(print_assignment: ret assign ->
  $texp = {decomp assign};
  texp (-> return ret 0)
)
(print_assign_cont: assign cont ->
  $texp = {decomp assign};
  texp cont
)

(read_function_application: context fname_l fname_r l r is_returning cont ->
  $l r = {read_whitespace_ret l r};
  read_identifier_func l r
  (l r il ir -> read_func_operand_list context fname_l fname_r l r
    (op_list l r ->
    ${if {compare_bool il ir} (break ->
      ${if {compare_bool {tree_size op_list} 0} (break2 ->
        cont l r context (cont2 -> cont2)
      )};
      break
    )};
    cont l r context
      (cont2 ->
        print_cexp op_list (-> 
        ${if {ne il ir} (break ->
          ${if {search_tree_ret context il ir} (break2 -> 
            ${printf "push [{}{}]\n" fname_l fname_r il ir};
            break
          )};
          ${if is_returning (break2 ->
            ${printf "call {}\n" il ir};
            cont2
          )};
          ${printf "jmp {}\n" il ir};
          cont2
        )};
        is_returning
          (-> ${printf "call runtime_call_ret\n"};
            cont2
          )
          (->
            ${printf "jmp runtime_call\n"};
           cont2)
        )
      )
    )
  )
)

(read_until: c l r cont ->
  $lb = {deref_byte l};
  compare lb c (-> cont l r) (->
  $l = {add_func l 1};
  read_until c l r cont
))

(read_const_string: context fname_l fname_r l r cont ->
  read_whitespace_func l r (l_start r ->
  $lb = {deref_byte l_start};
  ${if {ne lb 34} (break -> cont l r 0)};
  $l = {add_func l_start 1};
  read_until 34 l r (l r ->
  $l_end = {add_func l 1};
  cont l_end r (!->
    $il ir = {gen_label_ret};
    ${printf "jmp {}_end\n{}: db {}\ndb 0\n{}_end: push {}\n" il ir il ir l_start l_end il ir il ir};
  )
)))

(print_aexp: context fname_l fname_r l r cont -> 
  $lb = {deref_byte l};
  compare lb 124
  (-> aexp_closure_help context fname_l fname_r l r cont)
  (-> not_body_closure_compare context fname_l fname_r l r cont)
)

(aexp_closure_help: context fname_l fname_r l r cont ->
  parse_closure l r
  (l r ->
    ${printf "push rax\n"};
    cont
  )
)

(not_body_closure_compare: comb_args fname_l fname_r l r cont ->
  $dig = {deref_byte l};
  $res = {is_alpha_ret dig};
  ${if {compare_bool res 1} (break_o ->
    search_tree comb_args l r (bool ->
    ${if bool (break ->
      ${printf "push [{}{}]\n" fname_l fname_r l r};
      cont
    )};
    break_o
  ))};
  ${printf "push {}\n" l r};
  cont
)

(parse_function_help: lo hi ->
  $nil = {make_nil};
  $l r fl fr context func = {parse_function nil 0 0 lo hi};
  func (-> main_loop l r)
)

(parse_closure_outer: lo hi -> parse_closure lo hi (l r -> main_loop l r)) ; takes (lo hi)

(parse_comment: lo hi -> 
  ${if {compare_bool lo hi} (break -> main_loop lo hi)};
  ${if {compare_bool {deref_byte lo} 10} (break -> main_loop lo hi)};
  parse_comment {add_func lo 1} hi
)

(parse_escape: l r ->
  $a = {add_func l 1};
  $b = {add_func l 2};
  ${print_range_ret a b};
  main_loop b r
)

(otherwise: lo hi ->
  $mid = {add_func lo 1};
  ${print_range_ret lo mid};
  main_loop mid hi
)

(main_loop: lo hi ->
  ${if {compare_bool} lo hi (break -> exit)};
  $c = {deref_byte lo};
  ${if {compare_bool c 40} (break -> parse_function_help lo hi)};
  ${if {compare_bool c 124} (break -> parse_closure_outer lo hi)};
  ${if {compare_bool c 59} (break -> parse_comment lo hi)};
  ${if {compare_bool c 92} (break -> parse_escape lo hi)};
  otherwise lo hi
)

start:
; open input
mov r6, 0x0             ; READ_ONLY
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+16]            ; argv[1]
mov r0, 2
syscall
mov r8, r0              ; save input file descriptor
; open output
mov r0, 2               ; fopen
mov r6, 0x242           ; truncate/create/READ_WRITE
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+24]            ; argv[2]
syscall
mov [outf], r0
; get input size
sub rsp, 0xC0            ; fstat size
mov r7, r8              ; input file descriptor
mov r6, rsp              ; fstat buffer
mov r0, 5               ; fstat
syscall
mov r10, [rsp+48]            ; file size
mov [flen], r10

; mmap input
mov r0, 9               ; mmap
mov r7, 0               ; address
mov r6, [flen]              ; length
mov r2, 3               ; PROT_READ | PROT_WRITE
mov r10, 2              ; MAP_PRIVATE
mov r9, 0               ; offset
syscall

mov r8, r0              ; save mmap address

; make heap
mov r7, 0               ; adress
mov r6, [flen]             ; length
shl r6, 8               ; 64 * file size, should be good

mov r2, 3               ; PROT_READ | PROT_WRITE
mov r10, 0x22           ; MAP_SHARED | MAP_ANONYMOUS
push r8                 ; save r8
mov r8, -1              ; file descriptor empty, anonymous
mov r9, 0               ; offset
mov r0, 9               ; mmap
syscall
pop r8                  ; restore r8
mov r14, r0             ; save instruction location array end
mov r15, [flen]            ; store max length of instruction location array
shl r15, 4              ; 16 * file size

mov [iter], 2
push r14
push r8

add [flen], r8

push [flen]
push r8
jmp main_loop
