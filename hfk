jmp start

deref_byte: ; takes (ptr) and returns *ptr
  pop rdx
  pop rax
  push rdx
  movb rax, [rax]
  and rax, 0xFF
  ret

return:
  pop rcx
  pop rax
  push rcx
  ret

load_func: ; (ptr cont) -> cont *ptr
  pop rax
  pop rdx
  mov rax, [rax]
  push rax
  push rdx
  jmp runtime_call

store_func: ; (ptr x cont) -> *ptr = x; cont
  pop rax
  pop rdx
  mov [rax], rdx
  jmp runtime_call

add_func: ; takes (ret a b) and returns a+b
  pop rbx
  pop rax
  pop rcx
  push rbx
  add rax, rcx
  ret

compare: ; takes in (a b equal_cont diff_cont) and calls equal_cont or diff_cont depending on a == b
  pop rax
  pop rcx
  pop rdi
  pop rsi
  cmp rax, rcx
  jne compare_fail
  push rdi
  jmp runtime_call

  compare_fail:
    push rsi
    jmp runtime_call

(if: ret v cont ->
  $break = (-> |return| ret 0);
  v (-> cont break) break
)

(if_ne: a b cont_ne cont_e -> |compare| a b cont_e cont_ne)

(!compare_bool: a b ->
  |callcc| (ret -> |compare| a b (-> ret (x y -> x)) (-> ret (x y -> y)))
)
constant_strings:
push_string:
dq "push "
jmp_string:
dq "jmp "
newline_string:
dq 10

inpf: dq 0
outf: dq 0
flen: dq 0
iter: dq 0
ofar: dq 0  ; offset array

exit:
  mov r0, 60
  mov r7, 0
  syscall

runtime_call:
  ; first input is closure containing \| number of operands including function, function, environment \|
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_loop
  
  pop rax
  jmp rax

runtime_call_ret:
  ; first input is closure containing \| number of operands including function, function, environment \|
  pop rbp
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_ret_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_ret_loop
  
  pop rax
  push rbp
  jmp rax

compute: ; (a b -> b (a)) execs a and gets value
  call runtime_call_ret
  pop rcx
  push rax
  push rcx
  jmp runtime_call

callcc: ; takes (cont -> ..) and returns the value that cont recieves
  |callcc_cont [rsp]|
  pop rcx
  pop rbx ; f
  push rax
  push rbx
  jmp runtime_call

  callcc_cont:
    pop rcx
    pop rax
    push rcx
    ret

page_pointer:
dq 0
memory_left:
dq 0
malloc:
  push rcx
  push rdx
  push rsi
  push rdi
  push r8
  push r9
  push r10
  push r11

  cmp [memory_left], rdi
  jl new_page
  jmp malloc_ret
  
  new_page:
  push rdi
  mov rsi, 4096
  mov rdi, 0               ; adress
  mov rdx, 3               ; PROT_READ \| PROT_WRITE
  mov r10, 0x22           ; MAP_SHARED \| MAP_ANONYMOUS
  mov r8, -1              ; file descriptor empty, anonymous
  mov r9, 0               ; offset
  mov rax, 9               ; mmap
  syscall
  pop rdi
  mov [page_pointer], rax
  mov [memory_left], 4096

  malloc_ret:
  mov rax, [page_pointer]
  add [page_pointer], rdi
  sub [memory_left], rdi

  pop r11
  pop r10
  pop r9
  pop r8
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  ret

(bool_true: cont_true cont_false -> cont_true)
(bool_false: cont_true cont_false -> cont_false)

(make_pair: cont a b -> cont (make_pair_lambda: cont -> cont a b))

(make_nil: cont -> cont (cont_nil cont_leaf cont_internal -> cont_nil))
(make_leaf: l r cont -> cont (cont_nil cont_leaf cont_internal -> cont_leaf l r))
(make_internal: a b cont -> cont (cont_nil cont_leaf cont_internal -> cont_internal a b))

(!make_nil_ret: -> |callcc| (ret -> |make_nil| ret))
(!make_leaf_ret: l r -> |return| (cont_nil cont_leaf cont_internal -> cont_leaf l r))
(!make_internal_ret: a b -> |return| (cont_nil cont_leaf cont_internal -> cont_internal a b))

make_leaf_imperative:
  push rsi
  push rdi
  call make_leaf_ret
  ret
  
make_internal_imperative:
  push rsi
  push rdi
  call make_internal_ret
  ret

prin:                   ; printst
push rax
push rcx
push rdx
push rsi
push rdi
push r11
mov rdx, rdi
mov rdi, [outf]
mov rsi, r4
add rsi, 56
mov rax, 1
syscall
pop r11
pop rdi
pop rsi
pop rdx
pop rcx
pop rax
ret

scmp:
  cmp rdi, rsi
  je end_of_string
  cmp rdx, rcx
  je end_of_string

  sub rax, rax
  movb al, [rdi]
  push rbx
  sub rbx, rbx
  movb bl, [rdx]
  sub rax, rbx
  pop rbx
  add rdi, 1
  add rdx, 1
  cmp rax, 0
  je scmp
  jl less
  mov rax, 1
  ret
  less:
  mov rax, -1
  ret

  end_of_string:
  mov rax, 0
  cmp rdi, rsi
  jne not_first_shorter
  add rax, -1
  not_first_shorter:
  cmp rdx, rcx
  jne not_second_shorter
  add rax, 1
  not_second_shorter:
  ret

cur_label:
  dq 1
gen_label:
  |cur_label|
  mov rdx, rax
  mov rcx, [cur_label]
  add [cur_label], 1
  mov [rdx], "f"
  add rdx, 1
  gen_label_loop:
  mov rbx, rcx
  and rbx, 7
  add rbx, "0"
  movb [rdx], rbx
  add rdx, 1
  shr rcx, 3
  cmp rcx, 0
  jne gen_label_loop
  ret

gen_label_func: ; (cont) -> (cont l r)
  call gen_label
  pop rcx
  push rdx
  push rax
  push rcx
  jmp runtime_call

str_equal_func: ; (a b l r cont)
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  call scmp
  cmp rax, 0
  je str_equal_equal
  
  |bool_false|
  pop rcx
  push rax
  push rcx
  jmp runtime_call

  str_equal_equal:
  |bool_true|
  pop rcx
  push rax
  push rcx
  jmp runtime_call
  
id_func:
  jmp runtime_call

print_range: ; FOLLOWS SYSTEM V ABI
  ; prints [rdi, rsi) to outf
  mov rdx, rsi        ; length of print
  sub rdx, rdi
  mov rsi, rdi ; rsi already stores buffer lcoation
  mov rdi, [outf]
  mov rax, 1
  syscall
  ret

print_range_func:
  ; takes l r cont and prints l r then calls cont
  pop rdi
  pop rsi
  call print_range
  jmp runtime_call


print_range_line_func:
  ; takes l r cont and prints l r then calls cont
  pop rdi
  pop rsi
  call print_range_line
  jmp runtime_call


print_string_func:
  ; takes l len cont and prints l r then calls cont
  pop rdi
  pop rsi
  add rsi, rdi
  call print_range
  jmp runtime_call

print_substring_func:
  ; takes l a b cont and prints (l+a, l+b) then calls cont
  pop rax
  pop rdi
  pop rsi
  add rdi, rax
  add rsi, rax
  call print_range
  jmp runtime_call

print_substring_line_func:
  ; takes l a b cont and prints (l+a, l+b) then calls cont
  pop rax
  pop rdi
  pop rsi
  add rdi, rax
  add rsi, rax
  call print_range_line
  jmp runtime_call

print_string_line_func:
  ; takes l len cont and prints l r then calls cont
  pop rdi
  pop rsi
  add rsi, rdi
  call print_range_line
  jmp runtime_call

(print_tree: tree cont -> |traverse_tree| tree |print_range_func| cont)

(traverse_tree: tree action cont -> tree cont (l r -> action l r cont) 
(traverse_internal: a b -> |traverse_tree| a action (-> |traverse_tree| b action cont)))

; calls cont with new_tree
(map_tree: tree action cont -> tree
  (-> $nil = { |make_nil_ret| };
      cont nil)
  (l r -> action l r cont) 
(map_internal: a b -> |map_tree| a action (new_a -> |map_tree| b action (new_b -> |make_internal| new_a new_b cont))))

(reverse_tree: tree cont -> tree (-> |make_nil| cont) ( l r -> |make_leaf| l r cont)
(a b -> |reverse_tree| a (new_a -> |reverse_tree| b (new_b -> |make_internal| new_b new_a cont)))
)

(search_tree: tree l r cont -> tree (-> cont (a b -> |bool_false| a b)) (a b -> |str_equal_func| l r a b cont)
(a b -> |search_tree| a l r (res -> res (-> cont (a b -> |bool_true| a b)) (-> |search_tree| b l r cont))))

reverse_tree_imperative:
  sub rsp, 16
  mov [rsp], rdi
  |reverse_tree_lambda|
  mov [rsp+8], rax
  jmp reverse_tree
  reverse_tree_lambda:
    pop rax
    ret

map_tree_imperative:
  sub rsp, 24
  mov [rsp], rdi
  mov [rsp+8], rsi
  |map_tree_imperative_lambda|
  mov [rsp+16], rax
  jmp map_tree
  map_tree_imperative_lambda:
    pop rax
    ret

map_id_imperative:
  sub rsp, 24
  mov [rsp], rdi
  |make_leaf|
  mov [rsp+8], rax
  |map_id_imperative_lambda|
  mov [rsp+16], rax
  jmp map_tree
  map_id_imperative_lambda:
    pop rax
    ret

print_tree_imperative:
  sub rsp, 16
  mov [rsp], rdi
  |print_tree_imperative_done|
  mov [rsp+8], rax
  jmp print_tree
  print_tree_imperative_done:
  ret

print_range_pair:
  push rdi
  |print_range_pair_lambda|
  pop rdi
  push rax
  push rdi
  jmp runtime_call
  print_range_pair_lambda:
    pop rdi
    pop rsi
    call print_range
    ret

make_pair_imperative:
  push rsi
  push rdi
  |make_pair_imperative_lambda|
  push rax
  jmp make_pair
  make_pair_imperative_lambda:
    pop rax
    ret

print_ranges_function:

print_ranges:
  cmp rdi, 0
  jne print_ranges_continue
  ret
  print_ranges_continue:
  push rdi
  |print_ranges_lambda|
  pop rdi
  push rax
  push rdi
  jmp runtime_call
  print_ranges_lambda:
    pop rdi
    call print_range_pair
    pop rdi
    jmp print_ranges

print_range_line:
  call print_range
  call println
  ret

println:
  push 10
  mov rdi, 1
  call prin
  add rsp, 8
  ret


println_func:
  call println
  jmp runtime_call

is_alpha:           ; is alpha
  cmp r7, "a"      ; a
  jl nalp
  cmp r7, "z"     ; z
  jg nalp
  yalp:
  mov r0, 1
  ret
  nalp:
  mov r0, 0
  ret

is_alpha_func:
  pop rdi
  call is_alpha
  pop rcx
  push rax
  push rcx
  jmp runtime_call

(!is_alpha_ret: c -> |callcc| (ret -> |is_alpha_func| c ret))

is_digit:           ; is alpha
  cmp r7, "0"
  jl not_digit
  cmp r7, "9"
  jg not_digit
  yes_digit:
  mov r0, 1
  ret
  not_digit:
  mov r0, 0
  ret

peek_character:
  sub rax, rax
  cmp r8, [flen]
  je peek_character_ret
  movb rax, [r8]
  peek_character_ret:
  ret

read_whitespace:
  cmp r8, [flen]
  je done_whitespace
  cmpb [r8], " "
  je not_done_whitespace
  cmpb [r8], 10
  je not_done_whitespace
  done_whitespace:
  ret
  not_done_whitespace:
  add r8, 1
  jmp read_whitespace

read_whitespace_func: ; (r8 flen cont)
  pop r8
  pop [flen]
  call read_whitespace
  pop rax
  push [flen]
  push r8
  push rax
  jmp runtime_call

read_identifier: ; read identifier and return start and end pointers
  ; call read_whitespace
  push r8
  iloo:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  call is_alpha
  cmp rax, 1
  je identifier_loop_continue
  call is_digit
  cmp rax, 1
  je identifier_loop_continue
  cmp rcx, "_"
  je identifier_loop_continue
  jmp idon
  identifier_loop_continue:
  add r8, 1
  jmp iloo
  idon:
  pop rax
  mov rdx, r8
  ret

read_identifier_func: ; (r8 flen cont ->  l r r8 flen)
  pop r8
  pop [flen]
  call read_identifier
  pop rcx
  push [flen]
  push r8
  push rdx
  push rax
  push rcx
  jmp runtime_call

read_identifier_list:
  pop r8
  pop [flen]
  call make_nil_ret
  push rax

  id_list_loop:
  call read_whitespace
  call read_identifier
  cmp rax, rdx
  je id_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp id_list_loop

  id_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

(format_string: l r cont -> |make_nil| (tree ->
  |format_string_helper| tree l l r cont)
)
(format_substring: base l r cont ->
  $l = {|add_func| base l};
  $r = {|add_func| base r};
  |format_string| l r cont
)
(format_help: fmt a b -> 
  |compare| a 1
  (-> b fmt)
  (-> fmt a b (fmt -> |format_help| fmt))
)
(printf_help: fmt cont a b -> 
  |compare| a 1
  (-> cont fmt b)
  (-> fmt a b (fmt -> |printf_help| fmt cont))
)
(printf: base r -> |format_substring| base 0 r (fmt -> |printf_help| fmt (fmt cont -> |print_tree| fmt cont)))
; (!printf2_help: l r ->
;   ${|if| {|compare_bool| l r} (break ->
;     |return| 0
;   )};
  
; )

(format_string_helper: tree l mid r cont ->
  ${|if| {|compare_bool| mid r} (break ->
    cont {|make_internal_ret| tree {|make_leaf_ret| l mid}}
  )};
  ${|if| {|compare_bool| {|deref_byte| mid} 123} (break ->
    $new_mid = {|add_func| mid 2};
    $tree = {|make_internal_ret| tree {|make_leaf_ret| l mid}};
    cont (lb rb cont ->
      $tree = {|make_internal_ret| tree {|make_leaf_ret| lb rb}};
      |format_string_helper| tree new_mid new_mid r cont
    )
  )};
  $new_mid = {|add_func| mid 1};
  |format_string_helper| tree l new_mid r cont
)

read_operand_list:
  pop r8
  pop [flen]
  call make_nil_ret
  push rax

  op_list_loop:
  call read_whitespace
  call read_operand
  cmp rax, rdx
  je op_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp op_list_loop

  op_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

read_operand_list_imperative:
  sub rsp, 24
  mov [rsp], rdi
  mov [rsp+8], rsi
  |read_operand_list_imperative_lambda|
  mov [rsp+16], rax
  jmp read_operand_list
  read_operand_list_imperative_lambda:
    pop rax
    pop r8
    pop [flen]
    ret


read_operand:
  cmpb [r8], "\["
  jne read_identifier
  push r8
  memory_operand_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\]"
  je memory_operand_loop_done
  add r8, 1
  jmp memory_operand_loop
  memory_operand_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure:
  cmpb [r8], "\|"
  jne read_operand
  push r8
  add r8, 1
  id_or_closure_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\|"
  je id_or_closure_loop_done
  add r8, 1
  jmp id_or_closure_loop
  id_or_closure_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function:
  cmpb [r8], "\("
  jne read_id_or_closure
  push r8
  mov rax, 0
  id_or_closure_or_func_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  
  cmp rcx, "\("
  jne not_idocf_open
  add rax, 1
  not_idocf_open:
  cmp rcx, "\)"
  jne not_idocf_close
  sub rax, 1
  not_idocf_close:
  cmp rax, 0
  je id_or_closure_or_func_loop_done
  add r8, 1
  jmp id_or_closure_or_func_loop
  id_or_closure_or_func_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function_func: ; (l r -> a b l r)
  pop r8
  pop [flen]

  call read_id_or_closure_or_function
  pop rcx
  push [flen]
  push r8
  push rdx
  push rax
  push rcx
  jmp runtime_call

newline_leaf:
  dq 0
closure_tree:
  dq 0

closure_map_arg:
  jmp suff_strings_end
  mov_string:
  db "mov rcx, "
  mov_string_end:
  suff_strings:
  db "mov [rdx], rcx\\nadd rdx, 8\\n"
  suff_strings_end:
  lea rdi, [mov_string]
  lea rsi, [mov_string+9]
  call print_range
  pop rdi
  pop rsi
  call print_range_line
  lea rdi, [suff_strings]
  lea rsi, [suff_strings+26]
  call print_range

  pop rax
  push 0
  push rax
  jmp runtime_call


closure_header:
  dq "mov rdi,"
  dq " 800"
  
  dq "call mal"
  dq "loc"
  
  dq "lea rdx,"
  dq " [rax+8]"
closure_string:
db "mov rdi, 800\\ncall malloc\\nlea rdx, [rax+8]"

print_closure_help:
  pop rax
  pop rdi
  push rax
  jmp print_closure
print_closure:
  push rdi
  lea rdi, [newline_string]
  lea rsi, [newline_string+1]
  call make_pair_imperative
  mov rdi, rax
  mov rsi, 0
  call make_pair_imperative
  push rax
  lea rdi, [closure_header]
  lea rsi, [closure_header+12]
  call make_pair_imperative
  mov rdi, rax
  pop rsi
  call make_pair_imperative
  mov rdi, rax
  call print_ranges
  lea rdi, [closure_header+16]
  lea rsi, [closure_header+27]
  call make_leaf_imperative
  mov rdi, rax
  call print_tree_imperative
  call println
  lea rdi, [closure_header+32]
  lea rsi, [closure_header+48]
  call print_range_line

  |closure_map_arg|
  mov rsi, rax
  pop rdi
  call map_tree_imperative

  
  lea rdi, [closure_footer]
  lea rsi, [closure_footer+12]
  call print_range_line
  
  lea rdi, [closure_footer+16]
  lea rsi, [closure_footer+26]
  call print_range_line
  
  lea rdi, [closure_footer+32]
  lea rsi, [closure_footer+42]
  call print_range_line
  
  lea rdi, [closure_footer+48]
  lea rsi, [closure_footer+62]
  call print_range_line

  ret

brackets_string:
  dq "[\{}\{}]\\n"
brackets_string_2:
  db "[]"
(eof_closure_map_arg: fname_l fname_r pfname_l pfname_r l r cont -> |print_string_line_func| mov_string 9
(-> |compare| l fname_l
  (-> |print_range_line_func| l r (-> |print_string_func| suff_strings 26 (-> cont 0)))
  (-> |format_substring| brackets_string 0 7 
    (fmt -> |format_help| fmt pfname_l pfname_r l r 1
    (fmt -> |print_tree| fmt (-> |print_string_func| suff_strings 26 (-> cont 0)))))
))

print_closure_eof:
  pop [function_name]
  pop [function_name+8]
  pop [prev_function_name]
  pop [prev_function_name+8]
  pop rdi
  push rdi
  lea rdi, [newline_string]
  lea rsi, [newline_string]
  call make_leaf_imperative
  mov [closure_tree], rax
  
  lea rdi, [newline_string]
  lea rsi, [newline_string+1]
  call make_pair_imperative
  mov rdi, rax
  mov rsi, 0
  call make_pair_imperative
  push rax
  lea rdi, [closure_header]
  lea rsi, [closure_header+12]
  call make_pair_imperative
  mov rdi, rax
  pop rsi
  call make_pair_imperative
  mov rdi, rax
  call print_ranges
  lea rdi, [closure_header+16]
  lea rsi, [closure_header+27]
  call make_leaf_imperative
  mov rdi, rax
  call print_tree_imperative
  call println
  lea rdi, [closure_header+32]
  lea rsi, [closure_header+48]
  call print_range_line

  |eof_closure_map_arg [function_name] [function_name+8] [prev_function_name] [prev_function_name+8]|
  mov rsi, rax
  pop rdi
  call map_tree_imperative

  
  lea rdi, [closure_footer]
  lea rsi, [closure_footer+12]
  call print_range_line
  
  lea rdi, [closure_footer+16]
  lea rsi, [closure_footer+26]
  call print_range_line
  
  lea rdi, [closure_footer+32]
  lea rsi, [closure_footer+42]
  call print_range_line
  
  lea rdi, [closure_footer+48]
  lea rsi, [closure_footer+62]
  call print_range_line

  jmp runtime_call
  ret

closure_footer:
  dq "sub rdx,"
  dq " rax"
  dq "shr rdx,"
  dq " 3"
  dq "sub rdx,"
  dq " 1"
  dq "mov [rax"
  dq "], rdx"

(parse_closure: lo hi cont ->
  $lo = {|add_func| lo 1};
  |read_operand_list| lo hi (op_list lo hi -> 
    $lo = {|add_func| lo 1};
    $a = {|print_closure_help| op_list};
    cont lo hi
  )
)

function_name:
  dq 0
  dq 0

prev_function_name:
  dq 0
  dq 0
label_end_string:
  dq ":"
dq_string:
  dq ": dq 0"
push_start_string:
  dq "push ["
push_end_string:
  dq "]"
runtime_call_string:
  dq "jmp runt"
  dq "ime_call"
push_rax_string:
  db "push rax\\n"
print_label:
  pop rdi
  pop rsi
  call print_range
  lea rdi, [label_end_string]
  lea rsi, [label_end_string+1]
  call print_range_line
  jmp runtime_call

(map_argument: fname_l fname_r l r cont -> |format_substring| "{}{}: dq 0\n" 0 11
(fmt -> |format_help| fmt fname_l fname_r l r 1
(fmt -> |print_tree| fmt (-> cont 0))))

pop_start_string:
  dq "pop ["
pop_end_string:
  dq "]"
  
(print_pop_arg: p_fname_l p_fname_r l r cont -> |print_string_func| pop_start_string 5
(-> |print_range_func| p_fname_l p_fname_r
(-> |print_range_func| l r
(-> |print_string_func| pop_end_string 1
(-> |println_func|
(-> cont 0))))))

jmp_end_string:
  db "jmp \{}_end\\n"
  
end_label_string:
  db "_end:"
old_arg_list: dq 0
new_arg_list: dq 0
comb_arg_list: dq 0
temp_r8: dq 0
operand_list: dq 0

(parse_label: pl pr cont -> |read_whitespace_func| pl pr 
(l r -> (rest_label -> $lb = {|deref_byte| l};
  |compare| lb 33 (-> $l = {|add_func| l 1};
                  rest_label l r (a b -> a))
                  (-> rest_label l r (a b -> b)))
  (pl pr is_returning -> |read_identifier_func| pl pr
  (fl fr l r -> |read_whitespace_func| l r 
  (l r -> $l_char = { |deref_byte| l };
    |compare| l_char 58
    (pl_has_label: -> $l = {|add_func| l 1};
     cont l r fl fr is_returning)
    (pl_no_label: -> |gen_label_func| (fl fr -> cont pl pr fl fr is_returning)))))
  ))

(read_new_context: old_context l r cont -> |read_identifier_list| l r 
(new_args l r -> |make_internal| old_context new_args
(new_context -> cont new_context l r)))

(print_function_storage: context fname_l fname_r cont ->
(-> |map_tree| context  (l r cont -> |map_argument| fname_l fname_r l r cont) (extra_tree -> cont)))


function_storage_end:
db "pop rax\\npush rax\\n"
(print_function_init: context fname_l fname_r is_returning cont -> |print_label| fname_l fname_r
(rest_of_init -> is_returning (-> |print_string_func| function_storage_end 8 rest_of_init) rest_of_init)
(-> |map_tree| context (l r cont -> |print_pop_arg| fname_l fname_r l r cont) (extra_tree -> is_returning (-> |print_substring_func| function_storage_end 8 17 cont) cont)))

(parse_function: old_context p_fname_l p_fname_r l r cont ->
  |read_whitespace_func| l r
  (l r -> $lb = {|deref_byte| l};
  |compare| lb 40 (->
    $l_inner = {|add_func| l 1};
    |parse_label| l_inner r 
    (l r fname_l fname_r is_returning -> |read_new_context| old_context l r 
    (new_context l r -> |read_whitespace_func| l r
    (l r -> $l = {|add_func| l 2};
    |read_cexp| new_context fname_l fname_r l r
    (l r extra_context cexp -> $l = {|add_func| l 1};
    (-> cont l r (print_function: cont -> |format_substring| jmp_end_string 0 11 (fmt -> fmt fname_l fname_r (fmt -> |print_tree| fmt
      (-> |print_function_storage| extra_context fname_l fname_r
      (-> |print_function_init| new_context fname_l fname_r is_returning
      (-> cexp
      (-> |function_done| old_context fname_l fname_r p_fname_l p_fname_r is_returning cont))))))))))))
  )
  (-> cont l r 0)
))


function_done_string:
db "jmp runtime_call\\n\{}_end:\\n"
function_ret_done_string:
db "call runtime_call_ret\\nret\\n"
ret_string:
db "ret\\n"
(print_runtime_call_ret: cont -> |print_string_func| function_ret_done_string 26 cont)
(function_done: old_context fname_l fname_r p_fname_l p_fname_r is_returning cont ->
  (rest_of_done -> is_returning (-> |print_runtime_call_ret| rest_of_done) (-> |print_string_func| function_done_string 17 rest_of_done))
  (-> |format_substring| function_done_string 17 25
  (fmt -> fmt fname_l fname_r (fmt -> |print_tree| fmt
  (-> |make_leaf| fname_l fname_r (leaf -> |make_internal| leaf old_context
  (helper_tree -> |print_closure_eof| fname_l fname_r p_fname_l p_fname_r helper_tree cont)))))))

arg_l: dq 0
arg_r: dq 0

(read_func_operand_list: context fname_l fname_r l r cont -> |make_nil|
  (tree -> |read_func_operand_list_help| context fname_l fname_r l r tree cont)
)
(read_func_operand_list_help: context fname_l fname_r l r tree cont ->
  |read_whitespace_func| l r
  (l r -> |read_texp| context fname_l fname_r l r
  (l r texp ->
    |compare| texp 0 (-> cont tree l r)
    (->
      $leaf = {|make_leaf_ret| texp 0};
      $tree = {|make_internal_ret| tree leaf};
      |read_func_operand_list_help| context fname_l fname_r l r tree cont
    )
  )
))

(add_to_context: context l r cont -> |make_leaf| l r (leaf -> |make_internal| context leaf cont))

(read_texp: context fname_l fname_r l r cont ->
  (->
    $lb = { |deref_byte| l };
    |compare| lb 123
    (-> |read_block| context fname_l fname_r l r cont)
    (-> |read_aexp| context fname_l fname_r l r cont)
  )
)


function_ret_and_push_string:
db "call runtime_call_ret\\npush rax\\n"
(read_block: context fname_l fname_r l r cont ->
  $l = {|add_func| l 1};
  |read_whitespace_func| l r
  (l r -> |read_cexp| context fname_l fname_r l r
  (l r context cexp -> |read_whitespace_func| l r
  (l r -> $l = {|add_func| l 1};
  cont l r
    (cont -> cexp
    (-> |print_string_func| function_ret_and_push_string 31 cont)))))
)

; returns l r context cexp
(read_cexp: context fname_l fname_r l r cont -> |read_whitespace_func| l r
(l r -> $lb = { |deref_byte| l };
     |compare| lb 36
  (-> $l = {|add_func| l 1};
  |read_whitespace_func| l r
    (l r -> 
    ${|if| {|compare_bool| {|deref_byte| l} 123} (break ->
      |read_texp| context fname_l fname_r l r (l r texp ->
      $l = {|add_func| l 1};
      |read_cexp| context fname_l fname_r l r
      (l r context cexp -> cont l r context (cont ->
        (-> texp (-> |printf| "add rsp, 8\n" 11 1 (-> cexp cont))
      ))))
    )};
    |read_identifier_func| l r
    (il ir l r -> |add_to_context| context il ir
    (context -> |read_identifier_list| l r
    (ids l r -> $context = {|make_internal_ret| context ids};
    |read_whitespace_func| l r
    (l r -> $l = {|add_func| l 1};
    |read_whitespace_func| l r
    (l r -> |read_texp| context fname_l fname_r l r
    (l r texp -> |read_whitespace_func| l r
    (l r -> $l = {|add_func| l 1};
    |read_cexp| context fname_l fname_r l r
    (l r context cexp -> cont l r context 
        (cont -> texp
        (-> |print_pop_arg| fname_l fname_r il ir
        (a -> |map_tree| ids (l r -> |print_pop_arg| fname_l fname_r l r)
        (a -> cexp cont))))))))))))))
  (-> |read_function_application| context fname_l fname_r l r cont)))

(read_function_application: context fname_l fname_r l r cont -> |read_func_operand_list| context fname_l fname_r l r
    (op_list l r -> cont l r context (cont2 -> |print_cexp| op_list cont2)))
(print_cexp: aexp_list cont -> |reverse_tree| aexp_list
  (aexp_list ->|map_tree| aexp_list (aexp r cont -> aexp (-> cont 0))
  (aexp_list -> cont)))

; returns l r aexp
(read_aexp: context fname_l fname_r l r cont ->
  $dig = {|deref_byte| l};
  |parse_function| context fname_l fname_r l r (lo hi func -> |if_ne| func 0 (-> 
    cont lo hi (cont -> func (-> |print_string_func| push_rax_string 9 cont))
  )(->
  |read_const_string| context fname_l fname_r l r (lo hi string -> |if_ne| string 0 (-> 
    cont lo hi (cont -> string cont)
  )(->
  |read_id_or_closure_or_function_func| l r
    (a b l r -> |compare| a b (-> cont l r 0) (-> cont l r (cont2 -> |print_aexp| context fname_l fname_r a b cont2)))
)))))

(read_until: c l r cont ->
  $lb = {|deref_byte| l};
  |compare| lb c (-> cont l r) (->
  $l = {|add_func| l 1};
  |read_until| c l r cont
))

(read_const_string: context fname_l fname_r l r cont ->
  |read_whitespace_func| l r (l_start r ->
  $lb = {|deref_byte| l_start};
  |if_ne| lb 34 (-> cont l r 0) (->
  $l = {|add_func| l_start 1};
  |read_until| 34 l r (l r ->
  $l_end = {|add_func| l 1};
  cont l_end r (cont ->
    |gen_label_func| (il ir ->
    |printf| "jmp {}_end:\n{}: db {}\ndb 0\n{}_end: push {}\n" 43 il ir il ir l_start l_end il ir il ir 1 cont
     ))
))))

(print_aexp: context fname_l fname_r l r cont -> 
  $lb = {|deref_byte| l};
  |compare| lb 124
  (-> |aexp_closure_help| context fname_l fname_r l r cont)
  (-> |not_body_closure_compare| context fname_l fname_r l r cont)
)

(aexp_closure_help: context fname_l fname_r l r cont ->
  |parse_closure| l r
  (-> |printf| "push rax\n" 9 1 cont)
)

(not_body_closure_compare: comb_args fname_l fname_r l r cont ->
  $dig = {|deref_byte| l};
  $res = {|is_alpha_ret| dig};
  $cmp = {|compare_bool| res 1};
  $a = {|if| cmp (break_o ->
    |search_tree| comb_args l r
    (bool ->
    $a = {|if| bool (break -> |printf| "push [{}{}]\n" 12 fname_l fname_r l r 1 cont)};
    break_o
  ))};
  (-> |printf| "push {}\n" 8 l r 1 cont)
)

(parse_function_help: lo hi ->
  $nil = {|make_nil_ret|};
  |parse_function| nil 0 0 lo hi
  (l r func -> func (-> |main_loop| l r))
)

(parse_closure_outer: lo hi -> |parse_closure| lo hi (-> |main_loop|)) ; takes (lo hi)

(parse_comment: lo hi -> |compare| lo hi (-> |main_loop| lo hi)
  (->
    {|compare_bool| {|deref_byte| lo} 10}
    (-> |main_loop| lo hi)
    (-> 
      $lo = {|add_func| lo 1};
      |parse_comment| lo hi
    )
  )
)

(parse_escape: l r ->
  $a = {|add_func| l 1};
  $b = {|add_func| l 2};
  |print_range_func| a b
  (-> |main_loop| b r)
)

(print_char: lo hi ->
  $mid = {|add_func| lo 1};
  |print_range_func| lo mid
  (-> |main_loop| mid hi)
)

(main_loop: lo hi ->
  ${|if| {|compare_bool|} lo hi (break -> |exit|)};
  $c = {|deref_byte| lo};
  ${|if| {|compare_bool| c 40} (break -> |parse_function_help| lo hi)};
  ${|if| {|compare_bool| c 124} (break -> |parse_closure_outer| lo hi)};
  ${|if| {|compare_bool| c 59} (break -> |parse_comment| lo hi)};
  ${|if| {|compare_bool| c 92} (break -> |parse_escape| lo hi)};
  |print_char| lo hi
)

start:
; open input
mov r6, 0x0             ; READ_ONLY
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+16]            ; argv[1]
mov r0, 2
syscall
mov r8, r0              ; save input file descriptor
; open output
mov r0, 2               ; fopen
mov r6, 0x242           ; truncate/create/READ_WRITE
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+24]            ; argv[2]
syscall
mov [outf], r0
; get input size
sub rsp, 0xC0            ; fstat size
mov r7, r8              ; input file descriptor
mov r6, rsp              ; fstat buffer
mov r0, 5               ; fstat
syscall
mov r10, [rsp+48]            ; file size
mov [flen], r10

; mmap input
mov r0, 9               ; mmap
mov r7, 0               ; address
mov r6, [flen]              ; length
mov r2, 3               ; PROT_READ \| PROT_WRITE
mov r10, 2              ; MAP_PRIVATE
mov r9, 0               ; offset
syscall

mov r8, r0              ; save mmap address

; make heap
mov r7, 0               ; adress
mov r6, [flen]             ; length
shl r6, 8               ; 64 * file size, should be good

mov r2, 3               ; PROT_READ \| PROT_WRITE
mov r10, 0x22           ; MAP_SHARED \| MAP_ANONYMOUS
push r8                 ; save r8
mov r8, -1              ; file descriptor empty, anonymous
mov r9, 0               ; offset
mov r0, 9               ; mmap
syscall
pop r8                  ; restore r8
mov r14, r0             ; save instruction location array end
mov r15, [flen]            ; store max length of instruction location array
shl r15, 4              ; 16 * file size

mov [iter], 2
push r14
push r8

add [flen], r8

push [flen]
push r8
jmp main_loop
