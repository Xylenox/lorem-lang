jmp start

sysc:
    pop rcx

    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop r10
    pop r8
    pop r9

    push rcx
    syscall
    ret

deref_byte: ; takes (ptr) and returns *ptr
  pop rdx
  pop rax
  push rdx
  movb rax, [rax]
  and rax, 0xFF
  ret

return:
  pop rcx
  pop rax
  push rcx
  ret

load_func: ; (ptr) -> ret *ptr
  pop rdx
  pop rax
  mov rax, [rax]
  push rdx
  ret

store_func: ; (ptr x) -> *ptr = x; RET
  pop rdi
  pop rax
  pop rdx
  mov [rax], rdx
  push rdi
  ret

add_func: ; takes (ret a b) and returns a+b
  pop rbx
  pop rax
  pop rcx
  push rbx
  add rax, rcx
  ret

div_func:
  pop rcx
  pop rax
  mov rdx, 0
  pop rdi
  idiv rdi
  jmp rcx

mul_func: ; UNSIGNED
  pop rcx
  pop rax
  pop rdx
  mul rdx
  jmp rcx

mod_func:
  pop rcx
  pop rax
  mov rdx, 0
  pop rdi
  idiv rdi
  mov rax, rdx
  jmp rcx

decomp: ; takes (cont -> cont a b) and returns a and b
  |decomp_cont [rsp]|
  add rsp, 8
  pop rcx ; f
  push rax
  push rcx
  jmp runtime_call
  decomp_cont:
    pop rdi ; ret
    pop rax
    jmp rdi

compare: ; takes in (a b equal_cont diff_cont) and calls equal_cont or diff_cont depending on a == b
  pop rax
  pop rcx
  pop rdi
  pop rsi
  cmp rax, rcx
  jne compare_fail
  push rdi
  jmp runtime_call

  compare_fail:
    push rsi
    jmp runtime_call

(or: ret cont1 cont2) {
  cont1 () { return ret cont1 } () { return ret cont2 }
}

(if: ret v cont) {
  $break = () { return ret 0 };
  v () { cont break } break
}
(if_else: ret v cont1 cont2) {
  $break = () { return ret 0 };
  v () { cont1 break } () { cont2 break }
}
(if_ret: ret v cont) {
  $break = () { return ret 0 };
  v () {
    ${cont};
    break
  }
  break
}
(if_else_ret: ret v cont1 cont2) {
  v () { return ret {cont1} }
  () { return ret {cont2} }
}

(!ne: a b) {
  $res = [callcc (ret) { compare a b () { ret (x y) {y} } () { ret (x y) {x} } }];
  ! res
}
(!not: x) {
  $res = [callcc (ret) { x () { ret (a b) {b} } () { ret (a b) {a} } }];
  ! res
}

(!compare_bool: a b) {
  $res = [callcc (ret) { compare a b () { ret (x y) {x} } () { ret (x y) {y} } }];
  ! res
}

outf: dq 0
flen: dq 0

exit:
  mov r0, 60
  mov r7, 0
  syscall
error:
  mov [outf], 2
  jmp error_help
(error_help: num) {
  ${printf "error {}\n" num {add_func num 10}};
  ${sysc 60 1 0 0 0 0 0};
  exit
}

runtime_call:
  ; first input is closure containing | number of operands including function, function, environment |
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_loop
  
  pop rax
  jmp rax

runtime_call_ret:
  ; first input is closure containing | number of operands including function, function, environment |
  pop rbp
  mov rdx, [rsp]
  mov rcx, [rdx]
  shl rcx, 3
  add rdx, 8
  add rsp, 8
  sub rsp, rcx

  runtime_call_ret_loop:
  sub rcx, 8
  mov rax, [rdx+rcx]
  mov [rsp+rcx], rax
  cmp rcx, 0
  jne runtime_call_ret_loop
  
  pop rax
  push rbp
  jmp rax
  
callcc: ; takes (cont -> ..) and returns the value that cont recieves
  |callcc_cont [rsp]|
  pop rcx
  pop rbx ; f
  push rax
  push rbx
  jmp runtime_call

  callcc_cont:
    pop rcx
    pop rax
    push rcx
    ret

page_pointer:
dq 0
memory_left:
dq 0
malloc:
  push rcx
  push rdx
  push rsi
  push rdi
  push r8
  push r9
  push r10
  push r11

  cmp [memory_left], rdi
  jl new_page
  jmp malloc_ret
  
  new_page:
  push rdi
  mov rsi, 4096
  mov rdi, 0               ; adress
  mov rdx, 3               ; PROT_READ | PROT_WRITE
  mov r10, 0x22           ; MAP_SHARED | MAP_ANONYMOUS
  mov r8, -1              ; file descriptor empty, anonymous
  mov r9, 0               ; offset
  mov rax, 9               ; mmap
  syscall
  pop rdi
  mov [page_pointer], rax
  mov [memory_left], 4096

  malloc_ret:
  mov rax, [page_pointer]
  add [page_pointer], rdi
  sub [memory_left], rdi

  pop r11
  pop r10
  pop r9
  pop r8
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  ret

malloc_func:
  pop rcx
  pop rdi
  push rcx
  jmp malloc

(bool_true: cont_true cont_false) { cont_true }
(bool_false: cont_true cont_false) { cont_false }


(make_pair: cont a b) { cont (cont) {cont a b} }

(!make_nil:) { ! (cont_nil cont_leaf cont_internal) {cont_nil} }
(!make_leaf: l r) { ! (cont_nil cont_leaf cont_internal) {cont_leaf l r} }
(!make_internal: a b) { ! (cont_nil cont_leaf cont_internal) {cont_internal a b} }

make_leaf_imperative:
  push rsi
  push rdi
  call make_leaf
  ret
  
make_internal_imperative:
  push rsi
  push rdi
  call make_internal
  ret

prin:                   ; printst
push rax
push rcx
push rdx
push rsi
push rdi
push r11
mov rdx, rdi
mov rdi, [outf]
mov rsi, r4
add rsi, 56
mov rax, 1
syscall
pop r11
pop rdi
pop rsi
pop rdx
pop rcx
pop rax
ret

scmp:
  cmp rdi, rsi
  je end_of_string
  cmp rdx, rcx
  je end_of_string

  sub rax, rax
  movb al, [rdi]
  push rbx
  sub rbx, rbx
  movb bl, [rdx]
  sub rax, rbx
  pop rbx
  add rdi, 1
  add rdx, 1
  cmp rax, 0
  je scmp
  jl less
  mov rax, 1
  ret
  less:
  mov rax, -1
  ret

  end_of_string:
  mov rax, 0
  cmp rdi, rsi
  jne not_first_shorter
  add rax, -1
  not_first_shorter:
  cmp rdx, rcx
  jne not_second_shorter
  add rax, 1
  not_second_shorter:
  ret

cur_label:
  dq 1
gen_label_ret:
  mov rdi, 8
  call malloc
  mov rdx, rax
  mov rcx, [cur_label]
  add [cur_label], 1
  mov [rdx], "f"
  add rdx, 1
  gen_label_loop:
  mov rbx, rcx
  and rbx, 7
  add rbx, "0"
  movb [rdx], rbx
  add rdx, 1
  shr rcx, 3
  cmp rcx, 0
  jne gen_label_loop
  pop rcx
  push rdx
  jmp rcx

str_equal_func: ; (a b l r cont)
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  call scmp
  cmp rax, 0
  je str_equal_equal
  
  |bool_false|
  pop rcx
  push rax
  push rcx
  jmp runtime_call

  str_equal_equal:
  |bool_true|
  pop rcx
  push rax
  push rcx
  jmp runtime_call
  
print_range: ; FOLLOWS SYSTEM V ABI
  ; prints [rdi, rsi) to outf
  mov rdx, rsi        ; length of print
  sub rdx, rdi
  mov rsi, rdi ; rsi already stores buffer lcoation
  mov rdi, [outf]
  mov rax, 1
  syscall
  ret

print_char_help:
  push rdi
  mov rdx, 1
  mov rsi, rsp
  mov rdi, [outf]
  mov rax, 1
  syscall
  pop rdi
  ret

print_range_ret:
  pop rax
  pop rdi
  pop rsi
  push rax
  call print_range
  ret

print_char:
  pop rax
  pop rdi
  push rax
  call print_char_help
  ret

(print_num_help: v cont ->
  ${if {compare_bool v 0} (break -> cont)};
  print_num_help {div_func v 10} (->
    ${print_char {add_func {deref_byte "0"} {mod_func v 10}}};
    cont
  )
)
(print_num: ret v -> callcc ret (ret -> print_num_help v (-> ret 0)))

(printf: ret l ->
  $lb = {deref_byte l};
  ${if {compare_bool lb 0} (break ->
    return ret 0
  )};
  ${if {compare_bool lb 123} (break a b ->
    ${print_range_ret a b};
    printf ret {add_func l 2}
  )};
  ${print_char {deref_byte l}};
  printf ret {add_func l 1}
)

(tree_size: ret tree -> 
  tree
  (-> return ret 0)
  (l r -> return ret 1)
  (a b -> 
    $a = [tree_size a];
    $b = [tree_size b];
    return ret {add_func a b}
  )
)

(map_tree: ret tree action -> 
  tree
  (-> return ret {make_nil})
  (l r ->
    $res = [action l r];
    return ret res
  )
  (a b -> 
    $a = [map_tree a action];
    $b = [map_tree b action];
    return ret {make_internal a b}
  )
)

(map_tree_iota_help: ret n tree action ->
  tree
    (-> ret n {make_nil})
    (l r -> ret {add_func n 1} {action n l r})
    (a b -> map_tree_iota_help (na new_a -> map_tree_iota_help (nb new_b -> ret nb {make_internal new_a new_b}) na b action) n a action)
)
(map_tree_iota: ret tree action -> callcc ret (ret -> map_tree_iota_help (n t -> ret t) 0 tree action))

(reverse_tree: ret tree ->
  tree (-> return ret {make_nil}) (l r -> return ret {make_leaf l r})
  (a b ->
    $a = [reverse_tree a];
    $b = [reverse_tree b];
    return ret {make_internal b a}
  )
)

(search_tree: tree l r cont -> tree (-> cont (a b -> b)) (a b -> str_equal_func l r a b cont)
(a b -> search_tree a l r (res -> res (-> cont (a b -> bool_true a b)) (-> search_tree b l r cont))))

(!search_tree_ret: tree l r ->
  $res = [callcc (ret ->
    search_tree tree l r (res -> res (-> ret (a b -> a)) (-> ret (a b -> b)))
  )];
  ! res
)

print_range_pair:
  push rdi
  |print_range_pair_lambda|
  pop rdi
  push rax
  push rdi
  jmp runtime_call
  print_range_pair_lambda:
    pop rdi
    pop rsi
    call print_range
    ret

make_pair_imperative:
  push rsi
  push rdi
  |make_pair_imperative_lambda|
  push rax
  jmp make_pair
  make_pair_imperative_lambda:
    pop rax
    ret

print_range_line:
  call print_range
  call println
  ret

println:
  push 10
  mov rdi, 1
  call prin
  add rsp, 8
  ret


println_func:
  call println
  jmp runtime_call

is_alpha:           ; is alpha
  cmp r7, "a"      ; a
  jl nalp
  cmp r7, "z"     ; z
  jg nalp
  yalp:
  mov r0, 1
  ret
  nalp:
  mov r0, 0
  ret

is_alpha_func:
  pop rdi
  call is_alpha
  pop rcx
  push rax
  push rcx
  jmp runtime_call

(!is_alpha_ret: c ->
  $res = [callcc (ret -> is_alpha_func c ret)];
  ! res  
)

is_digit:           ; is alpha
  cmp r7, "0"
  jl not_digit
  cmp r7, "9"
  jg not_digit
  yes_digit:
  mov r0, 1
  ret
  not_digit:
  mov r0, 0
  ret

peek_character:
  sub rax, rax
  cmp r8, [flen]
  je peek_character_ret
  movb rax, [r8]
  peek_character_ret:
  ret

read_whitespace_imp:
  push [flen]
  push r8
  call read_whitespace
  mov r8, rax
  pop [flen]
  ret

(!read_whitespace: l r ->
  $lb = {deref_byte l};
  ${if {compare_bool l r} (break -> ! l r)};
  ${if {or {compare_bool lb 10} {compare_bool lb 32}} (break -> 
    $l r = [read_whitespace {add_func l 1} r];
    ! l r
  )};
  ! l r
)

read_identifier: ; read identifier and return start and end pointers
  ; call read_whitespace_imp
  push [flen]
  push r8
  call read_identifier_ret
  mov r8, rax
  pop [flen]
  pop rax
  pop rdx
  ret

read_identifier_ret:
  pop rcx
  pop r8
  pop [flen]
  push rcx
; call read_whitespace_imp
  push r8
  irloo:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  call is_alpha
  cmp rax, 1
  je identifier_ret_loop_continue
  call is_digit
  cmp rax, 1
  je identifier_ret_loop_continue
  cmp rcx, "_"
  je identifier_ret_loop_continue
  jmp irdon
  identifier_ret_loop_continue:
  add r8, 1
  jmp irloo
  irdon:
  pop rax
  mov rdx, r8
  pop rcx
  push rdx
  push rax
  push [flen]
  mov rax, r8
  jmp rcx

read_identifier_list_help:
  pop r8
  pop [flen]
  call make_nil
  push rax

  id_list_loop:
  call read_whitespace_imp
  call read_identifier
  cmp rax, rdx
  je id_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp id_list_loop

  id_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

(read_identifier_list: ret l r -> 
  read_identifier_list_help l r (ids l r -> return ret l r ids)
)

(format_string: l r cont -> format_string_helper {make_nil} l l r cont)
(format_substring: base l r cont ->
  $l = {add_func base l};
  $r = {add_func base r};
  format_string l r cont
)
(format_help: fmt a b -> 
  compare a 1
  (-> b fmt)
  (-> fmt a b (fmt -> format_help fmt))
)
(format_string_helper: tree l mid r cont ->
  ${if {compare_bool mid r} (break ->
    cont {make_internal tree {make_leaf l mid}}
  )};
  ${if {compare_bool {deref_byte mid} 123} (break ->
    $new_mid = {add_func mid 2};
    $tree = {make_internal tree {make_leaf l mid}};
    cont (lb rb cont ->
      $tree = {make_internal tree {make_leaf lb rb}};
      format_string_helper tree new_mid new_mid r cont
    )
  )};
  $new_mid = {add_func mid 1};
  format_string_helper tree l new_mid r cont
)

read_operand_list:
  pop r8
  pop [flen]
  call make_nil
  push rax

  op_list_loop:
  call read_whitespace_imp
  call read_operand
  cmp rax, rdx
  je op_list_done

  mov rdi, rax
  mov rsi, rdx
  call make_leaf_imperative
  
  pop rdi
  mov rsi, rax
  call make_internal_imperative
  push rax

  jmp op_list_loop

  op_list_done:
  pop rax
  pop rdi
  push [flen]
  push r8
  push rax
  push rdi
  jmp runtime_call

read_operand:
  cmpb [r8], "\["
  jne read_identifier
  push r8
  memory_operand_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\]"
  je memory_operand_loop_done
  add r8, 1
  jmp memory_operand_loop
  memory_operand_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure:
  cmpb [r8], "\|"
  jne read_operand
  push r8
  add r8, 1
  id_or_closure_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  cmp rcx, "\|"
  je id_or_closure_loop_done
  add r8, 1
  jmp id_or_closure_loop
  id_or_closure_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function:
  cmpb [r8], "\("
  jne read_id_or_closure
  push r8
  mov rax, 0
  id_or_closure_or_func_loop:
  sub rcx, rcx
  movb cl, [r8]
  mov rdi, rcx
  
  cmp rcx, "\("
  jne not_idocf_open
  add rax, 1
  not_idocf_open:
  cmp rcx, "\)"
  jne not_idocf_close
  sub rax, 1
  not_idocf_close:
  cmp rax, 0
  je id_or_closure_or_func_loop_done
  add r8, 1
  jmp id_or_closure_or_func_loop
  id_or_closure_or_func_loop_done:
  add r8, 1
  pop rax
  mov rdx, r8
  ret

read_id_or_closure_or_function_func: ; (l r -> a b l r)
  pop r8
  pop [flen]

  call read_whitespace_imp

  call read_id_or_closure_or_function
  pop rcx
  push [flen]
  push r8
  push rdx
  push rax
  push rcx
  jmp runtime_call

closure_map_arg:
  jmp suff_strings_end
  mov_string:
  db "mov rcx, "
  mov_string_end:
  suff_strings:
  db "mov [rdx], rcx\\nadd rdx, 8\\n"
  suff_strings_end:
  lea rdi, [mov_string]
  lea rsi, [mov_string+9]
  call print_range
  pop rax
  pop rdi
  pop rsi
  push rax
  call print_range_line
  lea rdi, [suff_strings]
  lea rsi, [suff_strings+26]
  call print_range

  ret

closure_header:
  dq "mov rdi,"
  dq " 800"
  
  dq "call mal"
  dq "loc"
  
  dq "lea rdx,"
  dq " [rax+8]"

print_closure_help:
  pop rax
  pop rdi
  push rax
  jmp print_closure
print_closure:
  push rdi
  lea rdi, [closure_header]
  lea rsi, [closure_header+12]
  call print_range_line
  lea rdi, [closure_header+16]
  lea rsi, [closure_header+27]
  call print_range_line
  lea rdi, [closure_header+32]
  lea rsi, [closure_header+48]
  call print_range_line

  |closure_map_arg|
  pop rdi
  push rax
  push rdi
  call map_tree

  
  lea rdi, [closure_footer]
  lea rsi, [closure_footer+12]
  call print_range_line
  
  lea rdi, [closure_footer+16]
  lea rsi, [closure_footer+26]
  call print_range_line
  
  lea rdi, [closure_footer+32]
  lea rsi, [closure_footer+42]
  call print_range_line
  
  lea rdi, [closure_footer+48]
  lea rsi, [closure_footer+62]
  call print_range_line
  ret

(!eof_closure_map_arg: fname_l fname_r pfname_l pfname_r ->
  ! (!n l r -> 
    ${if_else_ret {compare_bool l fname_l} (!->
      ${printf "mov [rax+"};
      ${print_num {mul_func 8 {add_func 1 n}}};
      ${printf "], {}\n" l r};
    ) (!->
      ${printf "mov rcx, [{}{}]\nmov [rax+" pfname_l pfname_r l r};
      ${print_num {mul_func 8 {add_func 1 n}}};
      ${printf "], rcx\n"};
    )};
  )
)

closure_footer:
  dq "sub rdx,"
  dq " rax"
  dq "shr rdx,"
  dq " 3"
  dq "sub rdx,"
  dq " 1"
  dq "mov [rax"
  dq "], rdx"

(parse_closure: lo hi cont ->
  $lo = {add_func lo 1};
  read_operand_list lo hi (op_list lo hi -> 
    $lo = {add_func lo 1};
    $a = {print_closure_help op_list};
    cont lo hi
  )
)



(matches: ret a b -> 
  ${if {compare_bool {deref_byte a} 0} (break -> return ret (a b -> a))};
  ${if {ne {deref_byte a} {deref_byte b}} (break -> return ret (a b -> b))};
  matches ret {add_func a 1} {add_func b 1}
)
; 0 -> special, 1 -> id, 2 -> number, 3 -> string, 4 -> comment, 5 -> newline, 6 -> eof
; returns l r type il ir
(read_token: ret l r ->
  $l r = {read_whitespace l r};
  ${if {compare_bool 34 {deref_byte l}} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "$" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "!" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "[" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "]" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "(" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches ")" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "{" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "}" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "=" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches ";" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches ":" l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "," l} (break -> return ret {add_func l 1} r 0 l {add_func l 1})};
  ${if {matches "->" l} (break -> return ret {add_func l 2} r 0 l {add_func l 2})};
  $l r il ir = {read_identifier_ret l r};
  ${if {ne il ir} (break -> return ret l r 1 il ir)};
  error l
)

(read_is_returning: ret l r ->
  $nl nr t tl tr = {read_token l r};
  ${if {matches "!" tl} (break ->
    return ret nl nr (a b -> a))
  };
  return ret l r (a b -> b)
)
(parse_label: ret pl pr ->
  $l r t fl fr = {read_token pl pr};
  ${if {ne t 1} (break -> 
    $fl fr = {gen_label_ret};
    return ret pl pr fl fr
  )};
  $l r t tl tr = {read_token l r};
  ${if {matches ":" tl} (break ->
    return ret l r fl fr
  )};
  $fl fr = {gen_label_ret};
  return ret pl pr fl fr
)

(read_function: ret p_fname_l p_fname_r orig_l r) {
  $l = orig_l;
  $l r t tl tr = {read_token l r};
  ${if {not {matches "(" tl}} (break -> return ret orig_l r 0)};
  $l r is_returning = {read_is_returning l r};
  $l r fname_l fname_r = {parse_label l r}; 
  $l r new_args = {read_identifier_list l r}; 
  $l r t tl tr = {read_token l r};
  ${if {matches ")" tl} (break) {
    $l r t tl tr = {read_token l r};
    ${if {not {matches "{" tl}} (break) { return ret orig_l r 0 }};
    $l r cexp = [read_cexp fname_l fname_r l r is_returning];
    $l r t tl tr = {read_token l r};
    ${if {not {matches "}" tl}} (break) { return ret orig_l r 0 }};
    return ret l r (cont) { cont fname_l fname_r new_args is_returning cexp }
  }};
  ${if {not {matches "->" tl}} (break -> return ret orig_l r 0)};
  $l r cexp = [read_cexp fname_l fname_r l r is_returning];
  $l r t tl tr = {read_token l r};
  ${if {not {matches ")" tl}} (break) { return ret orig_l r 0 }};
  return ret l r (cont -> cont fname_l fname_r new_args is_returning cexp)
}
(print_function: ret old_context func) {
  $fname_l fname_r func_args is_returning cexp = {decomp func};
  $new_context = {make_internal old_context func_args};
  $cids = [get_cexp_vars cexp];
  ${printf "jmp {}_end\n" fname_l fname_r};
  ${map_tree {make_internal new_context cids} (!l r) { ${printf "{}{}: dq 0\n" fname_l fname_r l r}; }};
  ${printf "{}:\n" fname_l fname_r};
  ${if_ret is_returning (!) { ${printf "pop rax\n"}; }};
  ${map_tree new_context (!l r) { ${printf "pop [{}{}]\n" fname_l fname_r l r}; }};
  ${if_ret is_returning (!) { ${printf "push rax\n"}; }};
  $[print_cexp new_context cexp];
  ${if_ret is_returning (!) { ${printf "ret\n"}; }};
  ${printf "{}_end:\n" fname_l fname_r};
  return ret 0
}

; returns l r texp
(read_texp: ret ids fname_l fname_r l r) {
  $return_pop =        (l r t) { return ret l r (x aexp rec_block block func) { x ids fname_l fname_r t } };
  $return_rec_block = (l r rb) { return ret l r (x aexp rec_block block func) { rec_block rb } };
  $return_block =      (l r b) { return ret l r (x aexp rec_block block func) { block b } };
  $return_func =       (l r f) { return ret l r (x aexp rec_block block func) { func f } };
  $return_aexp =       (l r a) { return ret l r (x aexp rec_block block func) { aexp a } };
  $l r = {read_whitespace l r};
  $lb = {deref_byte l};
  ${if {compare_bool lb 91} (break) {
    $l r t tl tr = {read_token l r};
    ${if {not {matches "[" tl}} (break) { return ret orig_l r 0 }};
    $l r cexp = [read_cexp fname_l fname_r l r (a b) { a }];
    $l r t tl tr = {read_token l r};
    ${if {not {matches "]" tl}} (break) { return ret orig_l r 0 }};
    return_rec_block l r (cont) { cont ids fname_l fname_r cexp }
  }};
  ${if {compare_bool lb 123} (break) {
    $l = [add_func l 1];
    $l r = [read_whitespace l r];
    $l r cexp = [read_cexp fname_l fname_r l r (a b) {a}];
    $l r = {read_whitespace l r};
    $l = [add_func l 1];
    return_block l r (cont) { cont ids fname_l fname_r cexp }
  }};
  $lo hi func = [read_function fname_l fname_r l r];
  ${if {ne func 0} (break) {
    return_func lo hi (cont) { cont ids fname_l fname_r func }
  }};
  $lo hi string = [read_const_string fname_l fname_r l r];
  ${if {ne string 0} (break) {
    return_pop lo hi (cont) {
      ${string}; 
      cont
    }
  }};
  read_id_or_closure_or_function_func l r
  (a b l r -> compare a b (-> return ret l r 0) (-> return_aexp l r (cont -> cont ids fname_l fname_r a b)))
}

(print_texp: ret old_context texp ->
  ${if {compare_bool texp 0} (break -> return ret 0)};
  texp
  (ids fname_l fname_r t ->
    t (-> ${map_tree ids (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    return ret 0
    )
  )
  (aexp ->
    $ids fname_l fname_r a b = {decomp aexp};
    $[print_aexp old_context fname_l fname_r a b];
    ${map_tree ids (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    return ret 0
  )
  (rec_block ->
    $ids fname_l fname_r cexp = {decomp rec_block};
    $context = {map_tree old_context (!l r ->
      ${if {search_tree_ret ids l r} (break -> ! {make_nil})};
      ! {make_leaf l r}
    )};
    ${map_tree context (!l r -> ${printf "push [{}{}]\n" fname_l fname_r l r};)};
    $[print_cexp old_context cexp];
    $rev_context = [reverse_tree context];
    $[printf "push rax\n"];
    ${map_tree ids (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    ${map_tree rev_context (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    return ret 0
  )
  (block ->
    $ids fname_l fname_r cexp = {decomp block};
    $[print_cexp old_context cexp];
    $[printf "push rax\n"];
    ${map_tree ids (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    return ret 0
  )
  (func ->
    $ids fname_l fname_r func = {decomp func}; 
    $fl fr func_args is_returning cexp = {decomp func};
    $[print_function old_context func];
    $context = {make_internal {make_leaf fl fr} old_context};
    ${printf "mov rdi, "};
    $size = {tree_size context};
    ${print_num {mul_func 8 {add_func 1 size}}};
    ${printf "\ncall malloc\n"};
    $map_arg = {eof_closure_map_arg fl fr fname_l fname_r};
    ${map_tree_iota context map_arg};
    ${printf "mov [rax], "};
    ${print_num size};
    ${printf "\n"};
    ${printf "push rax\n"};
    ${map_tree ids (!l r -> ${printf "pop [{}{}]\n" fname_l fname_r l r};)};
    return ret 0
  )
)

(read_until: c l r cont ->
  $lb = {deref_byte l};
  compare lb c (-> cont l r) (->
  $l = {add_func l 1};
  read_until c l r cont
))

(read_const_string: ret fname_l fname_r l r ->
  $l_start r = {read_whitespace l r};
  $lb = {deref_byte l_start};
  ${if {ne lb 34} (break -> return ret l r 0)};
  $l = {add_func l_start 1};
  read_until 34 l r (l r ->
  $l_end = {add_func l 1};
  return ret l_end r (!->
    $il ir = {gen_label_ret};
    ${printf "jmp {}_end\n{}: db {}\ndb 0\n{}_end: push {}\n" il ir il ir l_start l_end il ir il ir};
  )
))

(print_aexp: ret comb_args fname_l fname_r l r ->
  $dig = {deref_byte l};
  $res = {is_alpha_ret dig};
  ${if {compare_bool res 1} (break_o ->
    search_tree comb_args l r (bool ->
    ${if bool (break ->
      ${printf "push [{}{}]\n" fname_l fname_r l r};
      return ret 0
    )};
    break_o
  ))};
  ${printf "push {}\n" l r};
  return ret 0
)

; returns l r cexp
(read_cexp: ret fname_l fname_r orig_l r is_returning ->
  $l = orig_l;
  $l r assign = [read_assignment fname_l fname_r orig_l r is_returning];
  ${if {compare_bool assign 0} (break -> return ret l r 0)};
  $l r cexp = [read_cexp fname_l fname_r l r is_returning];
  return ret l r (cont -> cont assign cexp)
)

(print_cexp: ret context cexp ->
  $assign cexp = {decomp cexp};
  $[print_assignment context assign];
  ${if {compare_bool cexp 0} (break -> return ret 0)};
  $assign_vars = [get_assignment_vars assign];
  $[print_cexp {make_internal context assign_vars} cexp];
  return ret 0
)

(get_cexp_vars: ret cexp ->
  $assign cexp = {decomp cexp};
  $ids = [get_assignment_vars assign];
  ${if {compare_bool cexp 0} (break -> return ret ids)};
  $ids2 = [get_cexp_vars cexp];
  return ret {make_internal ids ids2}
)

(read_eq_if: ret need l r ->
  ${if need (break ->
    $l r t tl tr = {read_token l r};
    ${if {not {matches "=" tl}} (break -> return 0 0)};
    return ret l r
  )};
  return ret l r
)

(read_assignment: ret fname_l fname_r orig_l r is_returning ->
  $l = orig_l;
  $l r t tl tr = {read_token l r};
  ${if {matches "!" tl} (break ->
    $l r texps = {read_texp_list fname_l fname_r l r};
    return ret l r (a b c -> c texps)
  )};
  ${if {not {matches "$" tl}} (break -> 
    $l r cexp = [read_function_application fname_l fname_r orig_l r is_returning];
    ${if {compare_bool cexp 0} (break -> return ret l r 0)};
    return ret l r (a b c -> a cexp)
  )};
  $l r ids = {read_identifier_list l r};
  $is_empty_ids = {compare_bool {tree_size ids} 0};
  $ids = {if_else_ret is_empty_ids (!-> 
    $il ir = {gen_label_ret};
    ! {make_leaf il ir}
  )
  (!-> ! ids)};
  $l r = {read_eq_if {not is_empty_ids} l r};
  ${if {compare_bool 0 l} (break -> return ret orig_l r 0)};
  $l r texp = [read_texp ids fname_l fname_r l r];
  $l r t tl tr = {read_token l r};
  ${if {not {matches ";" tl}} (break -> return ret orig_l r 0)};
  return ret l r (a b c -> b ids texp)
)
(print_assignment: ret context assign ->
  assign (appl ->
    $[print_function_application context appl];
    return ret 0
  )
  (ids texp ->
    $[print_texp context texp];
    (-> return ret 0)
  )
  (texps ->
    ${map_tree {reverse_tree texps} (!texp r ->
      $[print_texp context texp];
      ${printf "pop rax\npop rcx\npush rax\npush rcx\n"};
    )};
    ${printf "pop rcx\npop rax\njmp rcx\n"};
    return ret 0
  )
)

(get_assignment_vars: ret assign ->
  assign (appl -> return ret {make_nil})
  (ids texp -> return ret ids)
  (texps -> return ret {make_nil})
)

(read_texp_list: ret fname_l fname_r l r -> 
  $l r tree = [read_texp_list_help fname_l fname_r l r {make_nil}];
  return ret l r tree
)
(read_texp_list_help: ret fname_l fname_r l r tree) {
  $nl nr t tl tr = [read_token l r];
  ${if {matches "," tl} (break) {
    read_texp_list_help ret fname_l fname_r nl nr tree
  }};
  $l r texp = [read_texp {make_nil} fname_l fname_r l r];
  ${if {compare_bool texp 0} (break) { return ret l r tree }};
  $leaf = {make_leaf texp 0};
  $tree = {make_internal tree leaf};
  read_texp_list_help ret fname_l fname_r l r tree
}

(read_function_application: ret fname_l fname_r orig_l r is_returning) {
  $l = orig_l;
  $l r = {read_whitespace l r};
  $l r il ir = {read_identifier_ret l r};
  $l r op_list = [read_texp_list fname_l fname_r l r];
  ${if {compare_bool il ir} (break ->
    ${if {compare_bool {tree_size op_list} 0} (break2 ->
      return ret l r 0
    )};
    break
  )};
  return ret l r (cont -> cont op_list fname_l fname_r il ir is_returning)
}
(print_function_application: ret context appl ->
  $op_list fname_l fname_r il ir is_returning = {decomp appl};
  $[map_tree {reverse_tree op_list} (!texp r -> ${print_texp context texp};)];
  ${if {ne il ir} (break ->
    ${if {search_tree_ret context il ir} (break2 -> 
      ${printf "push [{}{}]\n" fname_l fname_r il ir};
      break
    )};
    ${if_else_ret is_returning (!->
      ${printf "call {}\n" il ir};
    ) (!->
      ${printf "jmp {}\n" il ir};
    )};
    return ret 0
  )};
  ${if_else_ret is_returning (!->
    ${printf "call runtime_call_ret\n"};
  )
  (!->
    ${printf "jmp runtime_call\n"};
  )};
  return ret 0
)

(parse_function_help: lo hi ->
  $nil = {make_nil};
  $l r func = {read_function 0 0 lo hi};
  ${print_function nil func};
  main_loop l r
)

(parse_closure_outer: lo hi -> parse_closure lo hi (l r -> main_loop l r)) ; takes (lo hi)

(parse_comment: lo hi -> 
  ${if {compare_bool lo hi} (break -> main_loop lo hi)};
  ${if {compare_bool {deref_byte lo} 10} (break -> main_loop lo hi)};
  parse_comment {add_func lo 1} hi
)

(parse_escape: l r ->
  $a = {add_func l 1};
  $b = {add_func l 2};
  ${print_range_ret a b};
  main_loop b r
)

(otherwise: lo hi ->
  $mid = {add_func lo 1};
  ${print_range_ret lo mid};
  main_loop mid hi
)

(main_loop: lo hi ->
  ${if {compare_bool} lo hi (break -> exit)};
  $c = {deref_byte lo};
  ${if {compare_bool c 40} (break -> parse_function_help lo hi)};
  ${if {compare_bool c 124} (break -> parse_closure_outer lo hi)};
  ${if {compare_bool c 59} (break -> parse_comment lo hi)};
  ${if {compare_bool c 92} (break -> parse_escape lo hi)};
  otherwise lo hi
)

start:
; open input
mov r6, 0x0             ; READ_ONLY
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+16]            ; argv[1]
mov r0, 2
syscall
mov r8, r0              ; save input file descriptor
; open output
mov r0, 2               ; fopen
mov r6, 0x242           ; truncate/create/READ_WRITE
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+24]            ; argv[2]
syscall
mov [outf], r0
; get input size
sub rsp, 0xC0            ; fstat size
mov r7, r8              ; input file descriptor
mov r6, rsp              ; fstat buffer
mov r0, 5               ; fstat
syscall
mov r10, [rsp+48]            ; file size
mov [flen], r10

; mmap input
mov r0, 9               ; mmap
mov r7, 0               ; address
mov r6, [flen]              ; length
mov r2, 3               ; PROT_READ | PROT_WRITE
mov r10, 2              ; MAP_PRIVATE
mov r9, 0               ; offset
syscall

mov r8, r0              ; save mmap address

; make heap
mov r7, 0               ; adress
mov r6, [flen]             ; length
shl r6, 8               ; 64 * file size, should be good

mov r2, 3               ; PROT_READ | PROT_WRITE
mov r10, 0x22           ; MAP_SHARED | MAP_ANONYMOUS
push r8                 ; save r8
mov r8, -1              ; file descriptor empty, anonymous
mov r9, 0               ; offset
mov r0, 9               ; mmap
syscall
pop r8                  ; restore r8
mov r14, r0             ; save instruction location array end
mov r15, [flen]            ; store max length of instruction location array
shl r15, 4              ; 16 * file size

push r14
push r8

add [flen], r8

push [flen]
push r8
jmp main_loop
