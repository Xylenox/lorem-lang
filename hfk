; register layout
; ----------------
; r4 = pointer to input
; r9 = output file descriptor
; r10 = characters remaining in input
;
push start
push 0
|1 make_pair_test|
push rax
jmp make_pair
make_pair_test:
|1 call_start_with_pair|
pop rcx
push rax
push rcx
jmp runtime_call
call_start_with_pair:
pop rax
ret

constant_strings:
push_string:
dq "push "
jmp_string:
dq "jmp "
newline_string:
dq 10

inpf: dq 0
outf: dq 0
flen: dq 0
iter: dq 0
ofar: dq 0  ; offset array

exit:
    mov r0, 60
    mov r7, 0
    syscall

runtime_call:
    ; first input is closure containing \| number of operands including function, function, environment \|
    mov rdx, [rsp]
    mov rcx, [rdx]
    shl rcx, 3
    add rdx, 8
    add rsp, 8
    sub rsp, rcx

    runtime_call_loop:
    sub rcx, 8
    mov rax, [rdx+rcx]
    mov [rsp+rcx], rax
    cmp rcx, 0
    jne runtime_call_loop
    
    ret     ; fake ret lol

malloc:
    push rcx
    push rdx
    push rsi
    push rdi
    push r8
    push r9
    push r10
    push r11

    mov rsi, rdi
    mov rdi, 0               ; adress
    mov rdx, 3               ; PROT_READ \| PROT_WRITE
    mov r10, 0x22           ; MAP_SHARED \| MAP_ANONYMOUS
    mov r8, -1              ; file descriptor empty, anonymous
    mov r9, 0               ; offset
    mov rax, 9               ; mmap
    syscall

    pop r11
    pop r10
    pop r9
    pop r8
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    ret

compare: ; takes in (sucess_cont fail_cont a b) and calls success_cont or fail_cont depending on a == b
    mov rax, [rsp+16]
    mov rcx, [rsp+24]
    cmp rax, rcx
    jne compare_fail
    mov rax, [rsp]
    add rsp, 32
    push rax
    jmp runtime_call

    compare_fail:
        mov rax, [rsp+8]
        add rsp, 32
        push rax
        jmp runtime_call

(make_pair: cont a b -> cont |3 make_pair_lambda [a] [b]|)
(make_pair_lambda: a b cont -> cont a b)

prin:                   ; printst
push rax
push rcx
push rdx
push rsi
push rdi
push r11
mov rdx, rdi
mov rdi, [outf]
mov rsi, r4
add rsi, 56
mov rax, 1
syscall
pop r11
pop rdi
pop rsi
pop rdx
pop rcx
pop rax
ret

print_range: ; FOLLOWS SYSTEM V ABI
    ; prints [rdi, rsi) to outf
    mov rdx, rsi        ; length of print
    sub rdx, rdi
    mov rsi, rdi ; rsi already stores buffer lcoation
    mov rdi, [outf]
    mov rax, 1
    syscall
    ret

print_range_pair:
    push rdi
    |1 print_range_pair_lambda|
    pop rdi
    push rax
    push rdi
    jmp runtime_call
    print_range_pair_lambda:
        pop rdi
        pop rsi
        call print_range
        ret

make_pair_imperative:
    push rsi
    push rdi
    |1 make_pair_imperative_lambda|
    push rax
    jmp make_pair
    make_pair_imperative_lambda:
        pop rax
        ret

print_ranges_function:

print_ranges:
    cmp rdi, 0
    jne print_ranges_continue
    ret
    print_ranges_continue:
    push rdi
    |1 print_ranges_lambda|
    pop rdi
    push rax
    push rdi
    jmp runtime_call
    print_ranges_lambda:
        pop rdi
        call print_range_pair
        pop rdi
        jmp print_ranges

print_range_line:
    call print_range
    push 10
    mov rdi, 1
    call prin
    add rsp, 8
    ret

is_alpha:           ; is alpha
    cmp r7, "a"      ; a
    jl nalp
    cmp r7, "z"     ; z
    jg nalp
    yalp:
    mov r0, 1
    ret
    nalp:
    mov r0, 0
    ret

is_digit:           ; is alpha
    cmp r7, "0"
    jl not_digit
    cmp r7, "9"
    jg not_digit
    yes_digit:
    mov r0, 1
    ret
    not_digit:
    mov r0, 0
    ret

parse_comment:
    call peek_character
    cmp rax, 0x3B
    jne done_comment
    coml:
    call peek_character
    cmp rax, 10
    je done_comment
    add r8, 1
    jmp coml
    done_comment:
    ret

peek_character:
    sub rax, rax
    cmp r8, [flen]
    je peek_character_ret
    movb rax, [r8]
    peek_character_ret:
    ret

read_whitespace:
    cmp r8, [flen]
    je done_whitespace
    cmpb [r8], " "
    je not_done_whitespace
    cmpb [r8], 10
    je not_done_whitespace
    done_whitespace:
    ret
    not_done_whitespace:
    add r8, 1
    jmp read_whitespace

read_identifier: ; read identifier and return start and end pointers
    ; call read_whitespace
    push r8
    iloo:
    sub rcx, rcx
    movb cl, [r8]
    mov rdi, rcx
    call is_alpha
    cmp rax, 1
    je identifier_loop_continue
    call is_digit
    cmp rax, 1
    je identifier_loop_continue
    cmp rcx, "_"
    je identifier_loop_continue
    jmp idon
    identifier_loop_continue:
    add r8, 1
    jmp iloo
    idon:
    pop rax
    mov rdx, r8
    ret

read_operand:
    cmpb [r8], "\["
    jne read_identifier
    push r8
    memory_operand_loop:
    sub rcx, rcx
    movb cl, [r8]
    mov rdi, rcx
    cmp rcx, "\]"
    je memory_operand_loop_done
    add r8, 1
    jmp memory_operand_loop
    memory_operand_loop_done:
    add r8, 1
    pop rax
    mov rdx, r8
    ret

read_and_convert_operand:
    call read_operand
    mov rdi, rax
    mov rsi, rdx
    call make_pair_imperative
    ret

read_id_or_closure:
    cmpb [r8], "\|"
    jne read_identifier
    push r8
    add r8, 1
    id_or_closure_loop:
    sub rcx, rcx
    movb cl, [r8]
    mov rdi, rcx
    cmp rcx, "\|"
    je id_or_closure_loop_done
    add r8, 1
    jmp id_or_closure_loop
    id_or_closure_loop_done:
    add r8, 1
    pop rax
    mov rdx, r8
    ret


parse_closure:
    add r8, 1
    
    jmp closure_header_end
    closure_header:
    dq "mov rdi,"
    dq " 80"
    
    dq "call mal"
    dq "loc"
    
    dq "mov rdx,"
    dq " rax"
    closure_header_end:
    lea rdi, [newline_string]
    lea rsi, [newline_string+1]
    call make_pair_imperative
    mov rdi, rax
    mov rsi, 0
    call make_pair_imperative
    push rax
    lea rdi, [closure_header]
    lea rsi, [closure_header+11]
    call make_pair_imperative
    mov rdi, rax
    pop rsi
    call make_pair_imperative
    mov rdi, rax
    call print_ranges
    lea rdi, [closure_header+16]
    lea rsi, [closure_header+27]
    call print_range_line
    lea rdi, [closure_header+32]
    lea rsi, [closure_header+44]
    call print_range_line

    closure_loop:
    call read_whitespace
    cmpb [r8], "\|"
    je closure_loop_done
    jmp suff_strings_end
    mov_string:
    dq "mov rcx,"
    dq " "
    mov_string_end:
    suff_strings:
    dq "mov [rdx"
    dq "], rcx"
    dq "add rdx,"
    dq " 8"
    suff_strings_end:
    lea rdi, [mov_string]
    lea rsi, [mov_string+9]
    call print_range
    call read_operand
    mov rdi, rax
    mov rsi, rdx
    call print_range_line
    lea rdi, [suff_strings]
    lea rsi, [suff_strings+14]
    call print_range_line
    lea rdi, [suff_strings+16]
    lea rsi, [suff_strings+26]
    call print_range_line

    jmp closure_loop

    closure_loop_done:
    add r8, 1
    ret

function_name:
    dq 0
    dq 0
label_end_string:
    dq ":"
dq_string:
    dq ": dq 0"
pop_start_string:
    dq "pop ["
pop_end_string:
    dq "]"
push_start_string:
    dq "push ["
push_end_string:
    dq "]"
runtime_call_string:
    dq "jmp runt"
    dq "ime_call"
push_rax_string:
    dq "push rax"
print_label:
    call print_range
    lea rdi, [label_end_string]
    lea rsi, [label_end_string+1]
    call print_range_line
    ret
parse_function:
    add r8, 1
    call read_whitespace
    call read_identifier
    mov [function_name], rax
    mov [function_name+8], rdx
    add r8, 1

    push r8

    function_arg_loop:
    call read_whitespace
    cmpb [r8], "-"
    je function_arg_loop_done
    call read_identifier
    mov rdi, rax
    mov rsi, rdx
    call print_range
    lea rdi, [dq_string]
    lea rsi, [dq_string+6]
    call print_range_line
    jmp function_arg_loop

    function_arg_loop_done:
    mov rdi, [function_name]
    mov rsi, [function_name+8]
    call print_label
    call read_whitespace

    pop r8
    
    function_arg_loop_2:
    call read_whitespace
    cmpb [r8], "-"
    je function_arg_loop_done_2
    lea rdi, [pop_start_string]
    lea rsi, [pop_start_string+5]
    call print_range
    call read_identifier
    mov rdi, rax
    mov rsi, rdx
    call print_range
    lea rdi, [pop_end_string]
    lea rsi, [pop_end_string+1]
    call print_range_line
    jmp function_arg_loop_2
    function_arg_loop_done_2:
    add r8, 2

    mov rax, [argument_buffer_begin]
    mov [argument_buffer_end], rax
    function_body_loop:
    call read_whitespace
    cmpb [r8], "\)"
    je function_body_loop_end

    call read_id_or_closure
    mov rcx, [argument_buffer_end]
    mov [rcx], rax
    mov [rcx+8], rdx
    add [argument_buffer_end], 16
    jmp function_body_loop
    function_body_loop_end:
    add r8, 1
    function_body_reverse_loop:
    sub [argument_buffer_end], 16
    mov rcx, [argument_buffer_end]
    mov rdi, [rcx]
    cmpb [rdi], "\|"
    jne not_body_closure

    push r8
    mov r8, rdi
    call parse_closure
    pop r8

    lea rdi, [push_rax_string]
    lea rsi, [push_rax_string+8]
    call print_range_line
    jmp end_process_function_body

    not_body_closure:
    mov rcx, [argument_buffer_end]
    mov rdi, [rcx]
    movb dil, [rdi]
    and rdi, 0xFF
    call is_alpha
    cmp rax, 1
    je body_identifier
    
    body_constant:
    lea rdi, [push_start_string]
    lea rsi, [push_start_string+5]
    call print_range
    mov rcx, [argument_buffer_end]
    mov rdi, [rcx]
    mov rsi, [rcx+8]
    call print_range_line
    jmp end_process_function_body
    
    body_identifier:
    lea rdi, [push_start_string]
    lea rsi, [push_start_string+6]
    call print_range
    mov rcx, [argument_buffer_end]
    mov rdi, [rcx]
    mov rsi, [rcx+8]
    call print_range
    lea rdi, [push_end_string]
    lea rsi, [push_end_string+1]
    call print_range_line
    end_process_function_body:
    mov rcx, [argument_buffer_end]
    cmp rcx, [argument_buffer_begin]
    jne function_body_reverse_loop
    function_done:
    
    lea rdi, [runtime_call_string]
    lea rsi, [runtime_call_string+16]
    call print_range_line
    ret

argument_buffer_begin:
dq 0
argument_buffer_end:
dq 0

start:
; open input
mov r6, 0x0             ; READ_ONLY
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+16]            ; argv[1]
mov r0, 2
syscall
mov r8, r0              ; save input file descriptor
; open output
mov r0, 2               ; fopen
mov r6, 0x242           ; truncate/create/READ_WRITE
mov r2, 0xFFFF          ; all perms
mov r7, [rsp+24]            ; argv[2]
syscall
mov [outf], r0
; get input size
sub rsp, 0xC0            ; fstat size
mov r7, r8              ; input file descriptor
mov r6, rsp              ; fstat buffer
mov r0, 5               ; fstat
syscall
mov r10, [rsp+48]            ; file size
mov [flen], r10

; mmap input
mov r0, 9               ; mmap
mov r7, 0               ; address
mov r6, [flen]              ; length
mov r2, 3               ; PROT_READ \| PROT_WRITE
mov r10, 2              ; MAP_PRIVATE
mov r9, 0               ; offset
syscall

mov r8, r0              ; save mmap address

; make heap
mov r7, 0               ; adress
mov r6, [flen]             ; length
shl r6, 8               ; 64 * file size, should be good

mov r2, 3               ; PROT_READ \| PROT_WRITE
mov r10, 0x22           ; MAP_SHARED \| MAP_ANONYMOUS
push r8                 ; save r8
mov r8, -1              ; file descriptor empty, anonymous
mov r9, 0               ; offset
mov r0, 9               ; mmap
syscall
pop r8                  ; restore r8
mov r14, r0             ; save instruction location array end
mov [argument_buffer_begin], rax
mov [argument_buffer_end], rax
mov r15, [flen]            ; store max length of instruction location array
shl r15, 4              ; 16 * file size

mov [iter], 2
push r14
push r8

add [flen], r8

main:
    ; main loop
    cmp r8, [flen]
    je exit
    cmpb [r8], "\|"
    jne not_closure
    call parse_closure
    jmp main
    not_closure:

    cmpb [r8], "\("
    jne not_function
    call parse_function
    jmp main
    not_function:
    
    cmpb [r8], "\;"
    jne not_comment
    call parse_comment
    jmp main
    not_comment:

    cmpb [r8], "\\"
    jne not_escape
    add r8, 1
    not_escape:

    
    push [r8]
    mov rdi, 1
    call prin
    pop rax
    add r8, 1
    jmp main    

inva:
; invalid
sub r4, 24
mov [r4], "inva"
mov [r4+4], "lid "
mov [r4+8], "inst"
mov [r4+12], "ruct"
mov [r4+16], "ion"
mov [r4+20], 10

mov r7, 21
mov [outf], 0
call prin

add r4, 24

call exit
mov r0, r0
